/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck - Types are generated by Convex at deploy time
/**
 * Agentic Workflows for FaxBella
 *
 * Customer-defined automation workflows that trigger when faxes arrive.
 * Workflows are chains of sequential steps (route, email, tag, forward, etc.)
 * executed after inbound fax processing.
 *
 * Trigger types: on_receive, on_type, on_urgency, on_keyword
 * Action types: route_to, email_to, assign_to, tag, forward_fax, webhook,
 *               ai_summarize, delay, condition
 */

import { action, internalAction, internalMutation, internalQuery, mutation, query } from './_generated/server';
import { internal } from './_generated/api';
import { v } from 'convex/values';

/* ─── Constants ───────────────────────────────────────── */

const EMAILIT_ENDPOINT = 'https://api.emailit.com/v1/emails';
const FROM_ADDRESS = 'FaxBella <notifications@faxbella.com>';

/* ─── Auth Helper ─────────────────────────────────────── */

async function resolveCustomerFromSession(
    ctx: { db: any },
    sessionToken: string,
): Promise<{ customerId: any; email: string } | null> {
    const session = await ctx.db
        .query('passkeySessions')
        .withIndex('by_sessionToken', (q: any) => q.eq('sessionToken', sessionToken))
        .first();

    if (!session || session.expiresAt < Date.now()) {
        return null;
    }

    const customer = await ctx.db
        .query('customers')
        .withIndex('by_email', (q: any) => q.eq('email', session.email))
        .first();

    if (!customer) {
        return null;
    }

    return { customerId: customer._id, email: session.email };
}

/* ─── Workflow CRUD ───────────────────────────────────── */

export const createWorkflow = mutation({
    args: {
        sessionToken: v.string(),
        name: v.string(),
        description: v.optional(v.string()),
        triggerType: v.string(),
        triggerConfig: v.object({
            documentTypes: v.optional(v.array(v.string())),
            urgencyLevels: v.optional(v.array(v.string())),
            keywords: v.optional(v.array(v.string())),
        }),
        steps: v.array(v.object({
            id: v.string(),
            actionType: v.string(),
            config: v.object({
                recipientId: v.optional(v.string()),
                emailAddress: v.optional(v.string()),
                assigneeEmail: v.optional(v.string()),
                tagName: v.optional(v.string()),
                faxNumber: v.optional(v.string()),
                webhookUrl: v.optional(v.string()),
                delayMinutes: v.optional(v.number()),
                conditionField: v.optional(v.string()),
                conditionOperator: v.optional(v.string()),
                conditionValue: v.optional(v.string()),
            }),
            label: v.optional(v.string()),
        })),
        priority: v.optional(v.number()),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            throw new Error('Authentication required');
        }

        // Validate trigger type
        const validTriggers = ['on_receive', 'on_type', 'on_urgency', 'on_keyword'];
        if (!validTriggers.includes(args.triggerType)) {
            throw new Error(`Invalid trigger type: ${args.triggerType}`);
        }

        // Validate action types
        const validActions = [
            'route_to', 'email_to', 'assign_to', 'tag', 'forward_fax',
            'webhook', 'ai_summarize', 'delay', 'condition',
        ];
        for (const step of args.steps) {
            if (!validActions.includes(step.actionType)) {
                throw new Error(`Invalid action type: ${step.actionType}`);
            }
        }

        if (args.steps.length === 0) {
            throw new Error('Workflow must have at least one step');
        }

        const now = Date.now();

        // Auto-assign priority if not provided (append to end)
        let priority = args.priority ?? 0;
        if (priority === 0) {
            const existing = await ctx.db
                .query('workflows')
                .withIndex('by_customer', (q: any) => q.eq('customerId', auth.customerId))
                .collect();
            priority = existing.length + 1;
        }

        const workflowId = await ctx.db.insert('workflows', {
            customerId: auth.customerId,
            name: args.name,
            description: args.description,
            enabled: true,
            priority,
            triggerType: args.triggerType,
            triggerConfig: args.triggerConfig,
            steps: args.steps,
            totalExecutions: 0,
            createdAt: now,
        });

        return workflowId;
    },
});

export const updateWorkflow = mutation({
    args: {
        sessionToken: v.string(),
        workflowId: v.id('workflows'),
        name: v.optional(v.string()),
        description: v.optional(v.string()),
        triggerType: v.optional(v.string()),
        triggerConfig: v.optional(v.object({
            documentTypes: v.optional(v.array(v.string())),
            urgencyLevels: v.optional(v.array(v.string())),
            keywords: v.optional(v.array(v.string())),
        })),
        steps: v.optional(v.array(v.object({
            id: v.string(),
            actionType: v.string(),
            config: v.object({
                recipientId: v.optional(v.string()),
                emailAddress: v.optional(v.string()),
                assigneeEmail: v.optional(v.string()),
                tagName: v.optional(v.string()),
                faxNumber: v.optional(v.string()),
                webhookUrl: v.optional(v.string()),
                delayMinutes: v.optional(v.number()),
                conditionField: v.optional(v.string()),
                conditionOperator: v.optional(v.string()),
                conditionValue: v.optional(v.string()),
            }),
            label: v.optional(v.string()),
        }))),
        priority: v.optional(v.number()),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            throw new Error('Authentication required');
        }

        const workflow = await ctx.db.get(args.workflowId);
        if (!workflow || workflow.customerId !== auth.customerId) {
            throw new Error('Workflow not found');
        }

        const updates: Record<string, unknown> = { updatedAt: Date.now() };

        if (args.name !== undefined) updates.name = args.name;
        if (args.description !== undefined) updates.description = args.description;
        if (args.triggerType !== undefined) updates.triggerType = args.triggerType;
        if (args.triggerConfig !== undefined) updates.triggerConfig = args.triggerConfig;
        if (args.steps !== undefined) updates.steps = args.steps;
        if (args.priority !== undefined) updates.priority = args.priority;

        await ctx.db.patch(args.workflowId, updates);

        return { success: true };
    },
});

export const deleteWorkflow = mutation({
    args: {
        sessionToken: v.string(),
        workflowId: v.id('workflows'),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            throw new Error('Authentication required');
        }

        const workflow = await ctx.db.get(args.workflowId);
        if (!workflow || workflow.customerId !== auth.customerId) {
            throw new Error('Workflow not found');
        }

        await ctx.db.delete(args.workflowId);

        return { success: true };
    },
});

export const toggleWorkflow = mutation({
    args: {
        sessionToken: v.string(),
        workflowId: v.id('workflows'),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            throw new Error('Authentication required');
        }

        const workflow = await ctx.db.get(args.workflowId);
        if (!workflow || workflow.customerId !== auth.customerId) {
            throw new Error('Workflow not found');
        }

        await ctx.db.patch(args.workflowId, {
            enabled: !workflow.enabled,
            updatedAt: Date.now(),
        });

        return { enabled: !workflow.enabled };
    },
});

/* ─── Workflow Queries ────────────────────────────────── */

export const listWorkflows = query({
    args: {
        sessionToken: v.string(),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            return [];
        }

        const workflows = await ctx.db
            .query('workflows')
            .withIndex('by_customer', (q: any) => q.eq('customerId', auth.customerId))
            .collect();

        // Sort by priority (lower = first)
        const sorted = [...workflows].sort((a, b) => a.priority - b.priority);

        return sorted.map((w: any) => ({
            id: w._id,
            name: w.name,
            description: w.description,
            enabled: w.enabled,
            priority: w.priority,
            triggerType: w.triggerType,
            triggerConfig: w.triggerConfig,
            stepsCount: w.steps.length,
            totalExecutions: w.totalExecutions,
            lastExecutedAt: w.lastExecutedAt,
            createdAt: w.createdAt,
            updatedAt: w.updatedAt,
        }));
    },
});

export const getWorkflow = query({
    args: {
        sessionToken: v.string(),
        workflowId: v.id('workflows'),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            return null;
        }

        const workflow = await ctx.db.get(args.workflowId);
        if (!workflow || workflow.customerId !== auth.customerId) {
            return null;
        }

        return {
            id: workflow._id,
            name: workflow.name,
            description: workflow.description,
            enabled: workflow.enabled,
            priority: workflow.priority,
            triggerType: workflow.triggerType,
            triggerConfig: workflow.triggerConfig,
            steps: workflow.steps,
            totalExecutions: workflow.totalExecutions,
            lastExecutedAt: workflow.lastExecutedAt,
            createdAt: workflow.createdAt,
            updatedAt: workflow.updatedAt,
        };
    },
});

/* ─── Execution Log Queries ───────────────────────────── */

export const listExecutions = query({
    args: {
        sessionToken: v.string(),
        workflowId: v.id('workflows'),
        limit: v.optional(v.number()),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            return [];
        }

        // Verify workflow ownership
        const workflow = await ctx.db.get(args.workflowId);
        if (!workflow || workflow.customerId !== auth.customerId) {
            return [];
        }

        const limit = Math.min(args.limit || 25, 100);

        const executions = await ctx.db
            .query('workflowExecutions')
            .withIndex('by_workflow', (q: any) => q.eq('workflowId', args.workflowId))
            .order('desc')
            .take(limit);

        return executions.map((e: any) => ({
            id: e._id,
            workflowId: e.workflowId,
            inboundFaxId: e.inboundFaxId,
            status: e.status,
            stepsCompleted: e.stepsCompleted,
            totalSteps: e.totalSteps,
            stepResults: e.stepResults,
            error: e.error,
            startedAt: e.startedAt,
            completedAt: e.completedAt,
        }));
    },
});

/* ─── Queue Management ────────────────────────────────── */

export const listQueueItems = query({
    args: {
        sessionToken: v.string(),
        assigneeEmail: v.optional(v.string()),
        status: v.optional(v.string()),
        limit: v.optional(v.number()),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            return [];
        }

        const limit = Math.min(args.limit || 25, 100);
        const filterStatus = args.status || 'pending';

        let items;

        if (args.assigneeEmail) {
            items = await ctx.db
                .query('workflowQueues')
                .withIndex('by_assignee', (q: any) =>
                    q.eq('assigneeEmail', args.assigneeEmail).eq('status', filterStatus),
                )
                .order('desc')
                .take(limit);

            // Filter to only this customer's items
            items = items.filter((item: any) => item.customerId === auth.customerId);
        } else {
            items = await ctx.db
                .query('workflowQueues')
                .withIndex('by_customer', (q: any) => q.eq('customerId', auth.customerId))
                .order('desc')
                .take(limit);

            if (args.status) {
                items = items.filter((item: any) => item.status === args.status);
            }
        }

        return items.map((item: any) => ({
            id: item._id,
            assigneeEmail: item.assigneeEmail,
            inboundFaxId: item.inboundFaxId,
            workflowId: item.workflowId,
            status: item.status,
            notes: item.notes,
            assignedAt: item.assignedAt,
            completedAt: item.completedAt,
        }));
    },
});

export const updateQueueItem = mutation({
    args: {
        sessionToken: v.string(),
        queueItemId: v.id('workflowQueues'),
        status: v.string(),
        notes: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            throw new Error('Authentication required');
        }

        const item = await ctx.db.get(args.queueItemId);
        if (!item || item.customerId !== auth.customerId) {
            throw new Error('Queue item not found');
        }

        const validStatuses = ['pending', 'in_review', 'completed', 'dismissed'];
        if (!validStatuses.includes(args.status)) {
            throw new Error(`Invalid status: ${args.status}`);
        }

        const updates: Record<string, unknown> = { status: args.status };

        if (args.notes !== undefined) {
            updates.notes = args.notes;
        }

        if (args.status === 'completed' || args.status === 'dismissed') {
            updates.completedAt = Date.now();
        }

        await ctx.db.patch(args.queueItemId, updates);

        return { success: true };
    },
});

/* ─── Workflow Execution Engine ───────────────────────── */

/**
 * Main entry point called after inbound fax routing completes.
 * Finds all matching enabled workflows for the customer and executes them
 * in priority order.
 */
export const executeWorkflows = internalAction({
    args: {
        customerId: v.id('customers'),
        inboundFaxId: v.id('inboundFaxes'),
    },
    handler: async (ctx, args) => {
        // Get fax data
        const fax = await ctx.runQuery(internal.workflows.getInboundFaxInternal, {
            faxId: args.inboundFaxId,
        });
        if (!fax) {
            console.error('[WORKFLOWS] Inbound fax not found:', args.inboundFaxId);
            return;
        }

        // Get all enabled workflows for this customer, sorted by priority
        const workflows = await ctx.runQuery(internal.workflows.getEnabledWorkflows, {
            customerId: args.customerId,
        });

        if (workflows.length === 0) {
            return;
        }

        for (const workflow of workflows) {
            // Check if trigger matches
            const matches = doesTriggerMatch(workflow, fax);
            if (!matches) {
                continue;
            }

            // Execute the workflow
            try {
                await ctx.runAction(internal.workflows.runWorkflow, {
                    workflowId: workflow._id,
                    customerId: args.customerId,
                    inboundFaxId: args.inboundFaxId,
                    faxData: {
                        extractedText: fax.extractedText || '',
                        documentType: fax.documentType || '',
                        urgency: fax.urgency || '',
                        fromNumber: fax.fromNumber,
                        toNumber: fax.toNumber,
                        r2ObjectKey: fax.r2ObjectKey || '',
                    },
                    steps: workflow.steps,
                });
            } catch (err) {
                const errorMessage = err instanceof Error ? err.message : 'Unknown error';
                console.error(`[WORKFLOWS] Workflow ${workflow.name} failed:`, errorMessage);
            }
        }
    },
});

/**
 * Execute a single workflow with its steps sequentially.
 */
export const runWorkflow = internalAction({
    args: {
        workflowId: v.id('workflows'),
        customerId: v.id('customers'),
        inboundFaxId: v.id('inboundFaxes'),
        faxData: v.object({
            extractedText: v.string(),
            documentType: v.string(),
            urgency: v.string(),
            fromNumber: v.string(),
            toNumber: v.string(),
            r2ObjectKey: v.string(),
        }),
        steps: v.array(v.object({
            id: v.string(),
            actionType: v.string(),
            config: v.object({
                recipientId: v.optional(v.string()),
                emailAddress: v.optional(v.string()),
                assigneeEmail: v.optional(v.string()),
                tagName: v.optional(v.string()),
                faxNumber: v.optional(v.string()),
                webhookUrl: v.optional(v.string()),
                delayMinutes: v.optional(v.number()),
                conditionField: v.optional(v.string()),
                conditionOperator: v.optional(v.string()),
                conditionValue: v.optional(v.string()),
            }),
            label: v.optional(v.string()),
        })),
    },
    handler: async (ctx, args) => {
        const now = Date.now();
        const stepResults: Array<{
            stepId: string;
            actionType: string;
            status: string;
            result?: string;
            executedAt: number;
        }> = [];

        // Create execution record
        const executionId = await ctx.runMutation(internal.workflows.createExecution, {
            workflowId: args.workflowId,
            customerId: args.customerId,
            inboundFaxId: args.inboundFaxId,
            totalSteps: args.steps.length,
            startedAt: now,
        });

        let shouldSkipRemaining = false;

        for (const step of args.steps) {
            if (shouldSkipRemaining) {
                stepResults.push({
                    stepId: step.id,
                    actionType: step.actionType,
                    status: 'skipped',
                    result: 'Skipped due to condition',
                    executedAt: Date.now(),
                });
                continue;
            }

            try {
                const result = await executeStep(ctx, step, args);

                if (step.actionType === 'condition' && result === 'condition_false') {
                    shouldSkipRemaining = true;
                }

                stepResults.push({
                    stepId: step.id,
                    actionType: step.actionType,
                    status: 'success',
                    result: typeof result === 'string' ? result : 'completed',
                    executedAt: Date.now(),
                });
            } catch (err) {
                const errorMessage = err instanceof Error ? err.message : 'Unknown error';
                stepResults.push({
                    stepId: step.id,
                    actionType: step.actionType,
                    status: 'failed',
                    result: errorMessage,
                    executedAt: Date.now(),
                });
                console.error(`[WORKFLOWS] Step ${step.id} (${step.actionType}) failed:`, errorMessage);
                // Continue to next step even on failure (best-effort)
            }
        }

        // Update execution record
        const completedSteps = stepResults.filter((s) => s.status === 'success').length;
        const hasFailures = stepResults.some((s) => s.status === 'failed');
        const finalStatus = hasFailures ? 'failed' : 'completed';

        await ctx.runMutation(internal.workflows.completeExecution, {
            executionId,
            workflowId: args.workflowId,
            status: finalStatus,
            stepsCompleted: completedSteps,
            stepResults,
        });
    },
});

/* ─── Step Execution ──────────────────────────────────── */

async function executeStep(
    ctx: any,
    step: any,
    args: any,
): Promise<string> {
    switch (step.actionType) {
        case 'email_to':
            return await executeEmailTo(ctx, step.config, args);

        case 'assign_to':
            return await executeAssignTo(ctx, step.config, args);

        case 'tag':
            return await executeTag(ctx, step.config, args);

        case 'forward_fax':
            return await executeForwardFax(ctx, step.config, args);

        case 'webhook':
            return await executeWebhook(step.config, args);

        case 'ai_summarize':
            return await executeAiSummarize(args);

        case 'delay':
            return await executeDelay(step.config);

        case 'condition':
            return evaluateCondition(step.config, args);

        case 'route_to':
            return `Routed to recipient ${step.config.recipientId || 'unknown'}`;

        default:
            return `Unknown action type: ${step.actionType}`;
    }
}

async function executeEmailTo(
    ctx: any,
    config: any,
    args: any,
): Promise<string> {
    const emailitKey = process.env.EMAILIT_API_KEY;
    if (!emailitKey) {
        throw new Error('EMAILIT_API_KEY not configured');
    }

    const recipientEmail = config.emailAddress;
    if (!recipientEmail) {
        throw new Error('No email address configured for email_to step');
    }

    const summary = args.faxData.extractedText.slice(0, 300);

    const html = `<!DOCTYPE html>
<html><head><meta charset="utf-8" /></head>
<body style="margin:0;padding:24px;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;">
<h2 style="color:#1a1a1a;">Workflow Notification: New Fax</h2>
<p>A fax from <strong>${args.faxData.fromNumber}</strong> triggered an automated workflow.</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
<tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;color:#64748b;">Type</td>
<td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">${args.faxData.documentType || 'Unknown'}</td></tr>
<tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;color:#64748b;">Urgency</td>
<td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">${args.faxData.urgency || 'Routine'}</td></tr>
<tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;color:#64748b;">From</td>
<td style="padding:8px;border-bottom:1px solid #e2e8f0;">${args.faxData.fromNumber}</td></tr>
</table>
${summary ? `<div style="background:#f8fafc;padding:16px;border-radius:8px;margin:16px 0;"><p style="margin:0;color:#475569;font-size:14px;">${summary}...</p></div>` : ''}
<p style="color:#94a3b8;font-size:12px;margin-top:24px;">Automated by FaxBella Workflows</p>
</body></html>`;

    const response = await fetch(EMAILIT_ENDPOINT, {
        method: 'POST',
        headers: {
            Authorization: `Bearer ${emailitKey}`,
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            from: FROM_ADDRESS,
            to: recipientEmail,
            subject: `[FaxBella Workflow] New fax from ${args.faxData.fromNumber}`,
            html,
        }),
    });

    if (!response.ok) {
        throw new Error(`EmailIt returned ${response.status}`);
    }

    return `Email sent to ${recipientEmail}`;
}

async function executeAssignTo(
    ctx: any,
    config: any,
    args: any,
): Promise<string> {
    const assigneeEmail = config.assigneeEmail;
    if (!assigneeEmail) {
        throw new Error('No assignee email configured');
    }

    await ctx.runMutation(internal.workflows.createQueueItem, {
        customerId: args.customerId,
        assigneeEmail,
        inboundFaxId: args.inboundFaxId,
        workflowId: args.workflowId,
    });

    return `Assigned to ${assigneeEmail}`;
}

async function executeTag(
    ctx: any,
    config: any,
    args: any,
): Promise<string> {
    const tagName = config.tagName;
    if (!tagName) {
        throw new Error('No tag name configured');
    }

    // Find the document library entry for this fax and add the tag
    await ctx.runMutation(internal.workflows.addTagToFaxDocument, {
        customerId: args.customerId,
        sourceFaxId: String(args.inboundFaxId),
        tagName: tagName.trim().toLowerCase(),
    });

    return `Tagged with "${tagName}"`;
}

async function executeForwardFax(
    ctx: any,
    config: any,
    args: any,
): Promise<string> {
    const faxNumber = config.faxNumber;
    if (!faxNumber) {
        throw new Error('No fax number configured for forward');
    }

    if (!args.faxData.r2ObjectKey) {
        throw new Error('No document available to forward');
    }

    // Download PDF from R2
    const base64Data = await ctx.runAction(internal.r2.downloadToBuffer, {
        objectKey: args.faxData.r2ObjectKey,
    });

    // Send via Faxbot API
    const faxbotApiUrl = process.env.FAXBOT_API_URL;
    const faxbotApiKey = process.env.FAXBOT_API_KEY;

    if (!faxbotApiUrl || !faxbotApiKey) {
        throw new Error('FAXBOT_API_URL or FAXBOT_API_KEY not configured');
    }

    const response = await fetch(`${faxbotApiUrl}/send`, {
        method: 'POST',
        headers: {
            Authorization: `Bearer ${faxbotApiKey}`,
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            to: faxNumber,
            document: base64Data,
            documentType: 'application/pdf',
            subject: `Forwarded fax from ${args.faxData.fromNumber}`,
        }),
    });

    if (!response.ok) {
        throw new Error(`Fax forward failed: ${response.status}`);
    }

    return `Forwarded to ${faxNumber}`;
}

async function executeWebhook(
    config: any,
    args: any,
): Promise<string> {
    const webhookUrl = config.webhookUrl;
    if (!webhookUrl) {
        throw new Error('No webhook URL configured');
    }

    const payload = {
        event: 'workflow_trigger',
        faxId: String(args.inboundFaxId),
        fromNumber: args.faxData.fromNumber,
        toNumber: args.faxData.toNumber,
        documentType: args.faxData.documentType,
        urgency: args.faxData.urgency,
        extractedText: args.faxData.extractedText.slice(0, 2000),
        timestamp: Date.now(),
    };

    const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
    });

    if (!response.ok) {
        throw new Error(`Webhook returned ${response.status}`);
    }

    return `Webhook delivered to ${webhookUrl}`;
}

async function executeAiSummarize(
    args: any,
): Promise<string> {
    // Use the extracted text to produce a concise summary.
    // In production this would call Gemini, but for now return the first 500 chars
    // as a placeholder summary that the caller can use.
    const text = args.faxData.extractedText || '';
    if (!text) {
        return 'No text available to summarize';
    }

    const summary = text.slice(0, 500);
    return `AI Summary: ${summary}`;
}

async function executeDelay(config: any): Promise<string> {
    const minutes = config.delayMinutes || 0;
    if (minutes > 0) {
        // In Convex actions we cannot truly "sleep" for long durations.
        // For delays > 0, we log the intent. A production implementation
        // would use ctx.scheduler.runAfter to schedule the remaining steps.
        return `Delay step: ${minutes} minute(s) requested`;
    }
    return 'No delay configured';
}

function evaluateCondition(config: any, args: any): string {
    const field = config.conditionField;
    const operator = config.conditionOperator;
    const expectedValue = config.conditionValue;

    if (!field || !operator) {
        return 'condition_true'; // No condition = pass through
    }

    // Resolve the field value from fax data
    const fieldMap: Record<string, string> = {
        documentType: args.faxData.documentType,
        urgency: args.faxData.urgency,
        fromNumber: args.faxData.fromNumber,
        toNumber: args.faxData.toNumber,
        extractedText: args.faxData.extractedText,
    };

    const actualValue = (fieldMap[field] || '').toLowerCase();
    const expected = (expectedValue || '').toLowerCase();

    let result = false;

    switch (operator) {
        case 'equals':
            result = actualValue === expected;
            break;
        case 'not_equals':
            result = actualValue !== expected;
            break;
        case 'contains':
            result = actualValue.includes(expected);
            break;
        case 'not_contains':
            result = !actualValue.includes(expected);
            break;
        case 'starts_with':
            result = actualValue.startsWith(expected);
            break;
        default:
            result = true;
    }

    return result ? 'condition_true' : 'condition_false';
}

/* ─── Trigger Matching ────────────────────────────────── */

function doesTriggerMatch(workflow: any, fax: any): boolean {
    switch (workflow.triggerType) {
        case 'on_receive':
            return true; // Matches all incoming faxes

        case 'on_type': {
            const types = workflow.triggerConfig?.documentTypes || [];
            if (types.length === 0) return true;
            return types.includes(fax.documentType);
        }

        case 'on_urgency': {
            const levels = workflow.triggerConfig?.urgencyLevels || [];
            if (levels.length === 0) return true;
            return levels.includes(fax.urgency);
        }

        case 'on_keyword': {
            const keywords = workflow.triggerConfig?.keywords || [];
            if (keywords.length === 0) return true;
            const text = (fax.extractedText || '').toLowerCase();
            return keywords.some((kw: string) => text.includes(kw.toLowerCase()));
        }

        default:
            return false;
    }
}

/* ─── Internal Mutations / Queries ────────────────────── */

export const getInboundFaxInternal = internalQuery({
    args: { faxId: v.id('inboundFaxes') },
    handler: async (ctx, args) => {
        return await ctx.db.get(args.faxId);
    },
});

export const getEnabledWorkflows = internalQuery({
    args: { customerId: v.id('customers') },
    handler: async (ctx, args) => {
        const workflows = await ctx.db
            .query('workflows')
            .withIndex('by_customer_enabled', (q: any) =>
                q.eq('customerId', args.customerId).eq('enabled', true),
            )
            .collect();

        // Sort by priority ascending (lower = runs first)
        return [...workflows].sort((a, b) => a.priority - b.priority);
    },
});

export const createExecution = internalMutation({
    args: {
        workflowId: v.id('workflows'),
        customerId: v.id('customers'),
        inboundFaxId: v.id('inboundFaxes'),
        totalSteps: v.number(),
        startedAt: v.number(),
    },
    handler: async (ctx, args) => {
        return await ctx.db.insert('workflowExecutions', {
            workflowId: args.workflowId,
            customerId: args.customerId,
            inboundFaxId: args.inboundFaxId,
            status: 'running',
            stepsCompleted: 0,
            totalSteps: args.totalSteps,
            stepResults: [],
            startedAt: args.startedAt,
        });
    },
});

export const completeExecution = internalMutation({
    args: {
        executionId: v.id('workflowExecutions'),
        workflowId: v.id('workflows'),
        status: v.string(),
        stepsCompleted: v.number(),
        stepResults: v.array(v.object({
            stepId: v.string(),
            actionType: v.string(),
            status: v.string(),
            result: v.optional(v.string()),
            executedAt: v.number(),
        })),
    },
    handler: async (ctx, args) => {
        const now = Date.now();

        // Update execution record
        await ctx.db.patch(args.executionId, {
            status: args.status,
            stepsCompleted: args.stepsCompleted,
            stepResults: args.stepResults,
            completedAt: now,
        });

        // Update workflow stats
        const workflow = await ctx.db.get(args.workflowId);
        if (workflow) {
            await ctx.db.patch(args.workflowId, {
                totalExecutions: (workflow.totalExecutions || 0) + 1,
                lastExecutedAt: now,
                updatedAt: now,
            });
        }
    },
});

export const createQueueItem = internalMutation({
    args: {
        customerId: v.id('customers'),
        assigneeEmail: v.string(),
        inboundFaxId: v.id('inboundFaxes'),
        workflowId: v.id('workflows'),
    },
    handler: async (ctx, args) => {
        return await ctx.db.insert('workflowQueues', {
            customerId: args.customerId,
            assigneeEmail: args.assigneeEmail,
            inboundFaxId: args.inboundFaxId,
            workflowId: args.workflowId,
            status: 'pending',
            assignedAt: Date.now(),
        });
    },
});

export const addTagToFaxDocument = internalMutation({
    args: {
        customerId: v.id('customers'),
        sourceFaxId: v.string(),
        tagName: v.string(),
    },
    handler: async (ctx, args) => {
        // Find the document library entry for this fax
        const docs = await ctx.db
            .query('documentLibrary')
            .withIndex('by_customer', (q: any) => q.eq('customerId', args.customerId))
            .collect();

        const doc = docs.find((d: any) => d.sourceFaxId === args.sourceFaxId);
        if (!doc) {
            return; // Document not yet archived; tag will be skipped
        }

        if (!doc.tags.includes(args.tagName)) {
            await ctx.db.patch(doc._id, {
                tags: [...doc.tags, args.tagName],
            });
        }
    },
});
