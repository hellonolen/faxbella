/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck - Types are generated by Convex at deploy time
/**
 * Outbound Fax Sending for SaaS Customers
 *
 * Allows customers to send faxes via the HumbleFax API.
 * Uses the platform's shared fax number or customer's own credentials.
 * Supports R2 file attachments and fax resending.
 */

import { action, internalMutation, internalQuery, mutation, query } from './_generated/server';
import { v } from 'convex/values';
import { internal } from './_generated/api';

/* ─── Create Outbound Fax ──────────────────────────────── */

export const createOutboundFax = mutation({
    args: {
        sessionToken: v.string(),
        recipientNumber: v.string(),
        recipientName: v.optional(v.string()),
        subject: v.optional(v.string()),
        message: v.optional(v.string()),
        storageId: v.optional(v.id('_storage')),
        r2ObjectKey: v.optional(v.string()),
        fileName: v.optional(v.string()),
        fileSize: v.optional(v.number()),
        mimeType: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        // Validate session
        const session = await ctx.db
            .query('passkeySessions')
            .withIndex('by_sessionToken', (q) => q.eq('sessionToken', args.sessionToken))
            .first();
        if (!session || session.expiresAt < Date.now()) {
            throw new Error('Authentication required');
        }

        // Resolve customer from session email
        const customer = await ctx.db
            .query('customers')
            .withIndex('by_email', (q) => q.eq('email', session.email))
            .first();
        if (!customer) {
            throw new Error('Customer not found');
        }

        const now = Date.now();

        const faxId = await ctx.db.insert('outboundFaxes', {
            customerId: customer._id,
            recipientNumber: args.recipientNumber,
            recipientName: args.recipientName,
            subject: args.subject,
            message: args.message,
            storageId: args.storageId,
            r2ObjectKey: args.r2ObjectKey,
            fileName: args.fileName,
            fileSize: args.fileSize,
            mimeType: args.mimeType,
            status: 'queued',
            createdAt: now,
        });

        await ctx.scheduler.runAfter(0, internal.outboundFax.sendFaxAction, {
            outboundFaxId: faxId,
            customerId: customer._id,
            recipientNumber: args.recipientNumber,
            recipientName: args.recipientName,
            subject: args.subject,
            message: args.message,
            r2ObjectKey: args.r2ObjectKey,
        });

        return faxId;
    },
});

/* ─── Update Outbound Fax Status ───────────────────────── */

export const updateOutboundFax = internalMutation({
    args: {
        id: v.id('outboundFaxes'),
        status: v.optional(v.string()),
        providerFaxId: v.optional(v.string()),
        error: v.optional(v.string()),
        sentAt: v.optional(v.number()),
    },
    handler: async (ctx, args) => {
        const { id, ...patch } = args;
        const updates: Record<string, unknown> = {};

        if (patch.status !== undefined) updates.status = patch.status;
        if (patch.providerFaxId !== undefined) updates.providerFaxId = patch.providerFaxId;
        if (patch.error !== undefined) updates.error = patch.error;
        if (patch.sentAt !== undefined) updates.sentAt = patch.sentAt;

        await ctx.db.patch(id, updates);
    },
});

/* ─── Get Customer Credentials ─────────────────────────── */

export const getCustomerCredentials = internalQuery({
    args: { customerId: v.id('customers') },
    handler: async (ctx, args) => {
        return await ctx.db.get(args.customerId);
    },
});

/* ─── List Outbound Faxes (by customerId) ──────────────── */

export const listOutboundFaxes = query({
    args: { sessionToken: v.string() },
    handler: async (ctx, args) => {
        // Validate session
        const session = await ctx.db
            .query('passkeySessions')
            .withIndex('by_sessionToken', (q) => q.eq('sessionToken', args.sessionToken))
            .first();
        if (!session || session.expiresAt < Date.now()) {
            throw new Error('Authentication required');
        }

        // Resolve customer from session email
        const customer = await ctx.db
            .query('customers')
            .withIndex('by_email', (q) => q.eq('email', session.email))
            .first();
        if (!customer) {
            throw new Error('Customer not found');
        }

        return await ctx.db
            .query('outboundFaxes')
            .withIndex('by_customer', (q) => q.eq('customerId', customer._id))
            .order('desc')
            .take(50);
    },
});

/* ─── Get Single Outbound Fax (by email) ───────────────── */

export const getOutboundFax = query({
    args: {
        faxId: v.id('outboundFaxes'),
        customerEmail: v.string(),
    },
    handler: async (ctx, args) => {
        const customer = await ctx.db
            .query('customers')
            .withIndex('by_email', (q) => q.eq('email', args.customerEmail))
            .first();

        if (!customer) return null;

        const fax = await ctx.db.get(args.faxId);
        if (!fax || fax.customerId !== customer._id) return null;

        return {
            id: fax._id,
            recipientNumber: fax.recipientNumber,
            recipientName: fax.recipientName,
            subject: fax.subject,
            message: fax.message,
            status: fax.status,
            providerFaxId: fax.providerFaxId,
            error: fax.error,
            r2ObjectKey: fax.r2ObjectKey,
            fileName: fax.fileName,
            fileSize: fax.fileSize,
            mimeType: fax.mimeType,
            hasCoverPage: fax.hasCoverPage,
            hasFile: !!(fax.r2ObjectKey || fax.storageId),
            originalFaxId: fax.originalFaxId,
            createdAt: fax.createdAt,
            sentAt: fax.sentAt,
        };
    },
});

/* ─── List Outbound Faxes (by email) ───────────────────── */

export const listOutboundFaxesByEmail = query({
    args: { customerEmail: v.string() },
    handler: async (ctx, args) => {
        const customer = await ctx.db
            .query('customers')
            .withIndex('by_email', (q) => q.eq('email', args.customerEmail))
            .first();

        if (!customer) return [];

        return await ctx.db
            .query('outboundFaxes')
            .withIndex('by_customer', (q) => q.eq('customerId', customer._id))
            .order('desc')
            .take(50);
    },
});

/* ─── Resend Fax Action ────────────────────────────────── */

export const resendFax = action({
    args: {
        originalFaxId: v.id('outboundFaxes'),
        customerEmail: v.string(),
    },
    handler: async (ctx, args) => {
        const customer = await ctx.runQuery(internal.outboundFax.getCustomerForResend, {
            email: args.customerEmail,
        });
        if (!customer) throw new Error('Customer not found');

        const originalFax = await ctx.runQuery(internal.outboundFax.getFaxForResend, {
            faxId: args.originalFaxId,
            customerId: customer._id,
        });
        if (!originalFax) throw new Error('Original fax not found or access denied');

        const newFaxId = await ctx.runMutation(internal.outboundFax.createResendFax, {
            customerId: customer._id,
            recipientNumber: originalFax.recipientNumber,
            recipientName: originalFax.recipientName,
            subject: originalFax.subject,
            message: originalFax.message,
            r2ObjectKey: originalFax.r2ObjectKey,
            fileName: originalFax.fileName,
            fileSize: originalFax.fileSize,
            mimeType: originalFax.mimeType,
            originalFaxId: args.originalFaxId,
        });

        return { success: true, newFaxId: String(newFaxId) };
    },
});

/* ─── Internal Helpers for Resend ──────────────────────── */

export const getCustomerForResend = internalQuery({
    args: { email: v.string() },
    handler: async (ctx, args) => {
        const customer = await ctx.db
            .query('customers')
            .withIndex('by_email', (q) => q.eq('email', args.email))
            .first();

        if (!customer) return null;
        return { _id: customer._id, plan: customer.plan };
    },
});

export const getFaxForResend = internalQuery({
    args: {
        faxId: v.id('outboundFaxes'),
        customerId: v.id('customers'),
    },
    handler: async (ctx, args) => {
        const fax = await ctx.db.get(args.faxId);
        if (!fax || fax.customerId !== args.customerId) return null;

        return {
            recipientNumber: fax.recipientNumber,
            recipientName: fax.recipientName,
            subject: fax.subject,
            message: fax.message,
            r2ObjectKey: fax.r2ObjectKey,
            fileName: fax.fileName,
            fileSize: fax.fileSize,
            mimeType: fax.mimeType,
        };
    },
});

export const createResendFax = internalMutation({
    args: {
        customerId: v.id('customers'),
        recipientNumber: v.string(),
        recipientName: v.optional(v.string()),
        subject: v.optional(v.string()),
        message: v.optional(v.string()),
        r2ObjectKey: v.optional(v.string()),
        fileName: v.optional(v.string()),
        fileSize: v.optional(v.number()),
        mimeType: v.optional(v.string()),
        originalFaxId: v.id('outboundFaxes'),
    },
    handler: async (ctx, args) => {
        const now = Date.now();

        const newFaxId = await ctx.db.insert('outboundFaxes', {
            customerId: args.customerId,
            recipientNumber: args.recipientNumber,
            recipientName: args.recipientName,
            subject: args.subject,
            message: args.message,
            r2ObjectKey: args.r2ObjectKey,
            fileName: args.fileName,
            fileSize: args.fileSize,
            mimeType: args.mimeType,
            originalFaxId: args.originalFaxId,
            status: 'queued',
            createdAt: now,
        });

        await ctx.scheduler.runAfter(0, internal.outboundFax.sendFaxAction, {
            outboundFaxId: newFaxId,
            customerId: args.customerId,
            recipientNumber: args.recipientNumber,
            recipientName: args.recipientName,
            subject: args.subject,
            message: args.message,
            r2ObjectKey: args.r2ObjectKey,
        });

        return newFaxId;
    },
});

/* ─── Send Fax Action (Internal) ───────────────────────── */

export const sendFaxAction = action({
    args: {
        outboundFaxId: v.id('outboundFaxes'),
        customerId: v.id('customers'),
        recipientNumber: v.string(),
        recipientName: v.optional(v.string()),
        subject: v.optional(v.string()),
        message: v.optional(v.string()),
        r2ObjectKey: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        // Get customer credentials or use platform defaults
        const customer = await ctx.runQuery(internal.outboundFax.getCustomerCredentials, {
            customerId: args.customerId,
        });

        const accessKey = customer?.humbleFaxAccessKey || process.env.HUMBLEFAX_ACCESS_KEY;
        const secretKey = customer?.humbleFaxSecretKey || process.env.HUMBLEFAX_SECRET_KEY;

        if (!accessKey || !secretKey) {
            await ctx.runMutation(internal.outboundFax.updateOutboundFax, {
                id: args.outboundFaxId,
                status: 'failed',
                error: 'Fax credentials not configured',
            });
            return { success: false, error: 'Fax credentials not configured' };
        }

        try {
            const authHeader = 'Basic ' + btoa(`${accessKey}:${secretKey}`);

            // Download PDF from R2 if attachment exists
            let pdfBuffer: Buffer | null = null;
            if (args.r2ObjectKey) {
                const base64Data = await ctx.runAction(internal.r2.downloadToBuffer, {
                    objectKey: args.r2ObjectKey,
                });
                pdfBuffer = Buffer.from(base64Data, 'base64');
            }

            // Step 1: Create temp fax
            const createResponse = await fetch('https://api.humblefax.com/tmpFax', {
                method: 'POST',
                headers: {
                    'Authorization': authHeader,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    recipients: [parseInt(args.recipientNumber.replace(/\D/g, ''))],
                    pageSize: 'Letter',
                    subject: args.subject || 'Fax from FaxBella',
                    message: args.message || '',
                    toName: args.recipientName || '',
                }),
            });

            if (!createResponse.ok) {
                throw new Error(`Failed to create fax: ${createResponse.status}`);
            }

            const createData = await createResponse.json();
            const tmpFaxId = createData.data?.tmpFax?.id;

            if (!tmpFaxId) {
                throw new Error('No tmpFax ID returned');
            }

            // Step 2: Upload document to tmpFax if we have an attachment
            if (pdfBuffer) {
                const uploadResponse = await fetch(`https://api.humblefax.com/tmpFax/${tmpFaxId}/document`, {
                    method: 'POST',
                    headers: {
                        'Authorization': authHeader,
                        'Content-Type': 'application/pdf',
                    },
                    body: pdfBuffer,
                });

                if (!uploadResponse.ok) {
                    throw new Error(`Failed to upload document to fax: ${uploadResponse.status}`);
                }
            }

            // Step 3: Send the fax
            const sendResponse = await fetch(`https://api.humblefax.com/tmpFax/${tmpFaxId}/send`, {
                method: 'POST',
                headers: { 'Authorization': authHeader },
            });

            if (!sendResponse.ok) {
                throw new Error(`Failed to send fax: ${sendResponse.status}`);
            }

            const sendData = await sendResponse.json();
            const providerFaxId = sendData.data?.sentFax?.id?.toString();

            // Update status to sending
            await ctx.runMutation(internal.outboundFax.updateOutboundFax, {
                id: args.outboundFaxId,
                status: 'sending',
                providerFaxId,
                sentAt: Date.now(),
            });

            // Send confirmation notification (non-fatal)
            try {
                await ctx.runAction(internal.notifications.sendFaxConfirmation, {
                    customerEmail: customer?.email || '',
                    recipientNumber: args.recipientNumber,
                    recipientName: args.recipientName,
                    subject: args.subject,
                    faxId: String(args.outboundFaxId),
                });
            } catch (notifyError) {
                // Notification failure must not block fax delivery
                console.error('[OUTBOUND FAX] Confirmation notification failed:', notifyError);
            }

            // Archive to document library
            try {
                await ctx.runMutation(internal.documentLibrary.archiveDocument, {
                    customerId: args.customerId,
                    sourceType: 'outbound',
                    sourceFaxId: String(args.outboundFaxId),
                    title: args.subject || `Fax to ${args.recipientName || args.recipientNumber}`,
                    documentType: undefined,
                    fromNumber: undefined,
                    toNumber: args.recipientNumber,
                    numPages: undefined,
                    extractedText: args.message,
                    r2ObjectKey: args.r2ObjectKey,
                    fileName: undefined,
                    fileSize: undefined,
                    mimeType: 'application/pdf',
                });
            } catch (archiveError) {
                console.error('[OUTBOUND FAX] Document archive failed (non-fatal):', archiveError);
            }

            return { success: true, providerFaxId };

        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            console.error('[OUTBOUND FAX] ERROR:', errorMessage);

            await ctx.runMutation(internal.outboundFax.updateOutboundFax, {
                id: args.outboundFaxId,
                status: 'failed',
                error: errorMessage,
            });

            // Send failure alert notification (non-fatal)
            try {
                await ctx.runAction(internal.notifications.sendFaxFailureAlert, {
                    customerEmail: customer?.email || '',
                    recipientNumber: args.recipientNumber,
                    recipientName: args.recipientName,
                    error: errorMessage,
                    faxId: String(args.outboundFaxId),
                });
            } catch (notifyError) {
                console.error('[OUTBOUND FAX] Failure notification failed:', notifyError);
            }

            return { success: false, error: errorMessage };
        }
    },
});
