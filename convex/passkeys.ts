/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck - Types are generated by Convex at deploy time
/**
 * WebAuthn Passkey Authentication for FaxBella
 *
 * Provides passwordless authentication using the WebAuthn standard.
 * Stores credential public keys and session tokens in Convex.
 *
 * Flow:
 *   1. Registration: Generate challenge -> Client creates credential -> Store public key
 *   2. Authentication: Generate challenge -> Client signs challenge -> Verify + create session
 *   3. Session: Validate session token on protected routes
 */

import { mutation, query, internalMutation } from './_generated/server';
import { v } from 'convex/values';

// ─── Helpers ───────────────────────────────────────────────

function generateChallenge(): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < 64; i++) {
        result += chars[crypto.getRandomValues(new Uint32Array(1))[0] % chars.length];
    }
    return result;
}

function generateSessionToken(): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let token = 'fxb_sess_';
    for (let i = 0; i < 48; i++) {
        token += chars[crypto.getRandomValues(new Uint32Array(1))[0] % chars.length];
    }
    return token;
}

// Session expires after 30 days
const SESSION_DURATION_MS = 30 * 24 * 60 * 60 * 1000;

// ─── Registration ──────────────────────────────────────────

/**
 * Step 1 of registration: Generate a challenge for the client to sign.
 * Returns the challenge and relying party info needed by the browser WebAuthn API.
 */
export const generateRegistrationChallenge = mutation({
    args: {
        email: v.string(),
        displayName: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        const challenge = generateChallenge();
        const expiresAt = Date.now() + 5 * 60 * 1000; // 5 min

        // Store the challenge for verification
        await ctx.db.insert('passkeyChallenge', {
            email: args.email,
            challenge,
            type: 'registration',
            expiresAt,
            createdAt: Date.now(),
        });

        return {
            challenge,
            rp: {
                name: 'FaxBella',
                id: 'faxbella.com',
            },
            user: {
                id: args.email,
                name: args.email,
                displayName: args.displayName || args.email,
            },
            pubKeyCredParams: [
                { alg: -7, type: 'public-key' },   // ES256
                { alg: -257, type: 'public-key' },  // RS256
            ],
            authenticatorSelection: {
                authenticatorAttachment: 'platform',
                requireResidentKey: true,
                residentKey: 'required',
                userVerification: 'required',
            },
            timeout: 300000,
            attestation: 'none',
        };
    },
});

/**
 * Step 2 of registration: Verify the credential and store the public key.
 * The client sends back the credential response from navigator.credentials.create().
 */
export const verifyRegistration = mutation({
    args: {
        email: v.string(),
        challenge: v.string(),
        credentialId: v.string(),
        publicKey: v.string(),       // Base64-encoded public key
        algorithm: v.number(),       // COSE algorithm identifier
        transports: v.optional(v.array(v.string())),
        attestationObject: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        // Verify the challenge exists and hasn't expired
        const storedChallenge = await ctx.db
            .query('passkeyChallenge')
            .withIndex('by_email_challenge', (q) =>
                q.eq('email', args.email).eq('challenge', args.challenge)
            )
            .first();

        if (!storedChallenge) {
            throw new Error('Invalid or expired challenge');
        }

        if (storedChallenge.expiresAt < Date.now()) {
            await ctx.db.delete(storedChallenge._id);
            throw new Error('Challenge expired');
        }

        if (storedChallenge.type !== 'registration') {
            throw new Error('Wrong challenge type');
        }

        // Delete the used challenge
        await ctx.db.delete(storedChallenge._id);

        // Check if credential already exists
        const existing = await ctx.db
            .query('passkeyCredentials')
            .withIndex('by_credentialId', (q) => q.eq('credentialId', args.credentialId))
            .first();

        if (existing) {
            throw new Error('Credential already registered');
        }

        // Store the passkey credential
        await ctx.db.insert('passkeyCredentials', {
            email: args.email,
            credentialId: args.credentialId,
            publicKey: args.publicKey,
            algorithm: args.algorithm,
            transports: args.transports || [],
            signCount: 0,
            createdAt: Date.now(),
            lastUsedAt: Date.now(),
        });

        // Create a session immediately after registration
        const sessionToken = generateSessionToken();
        const expiresAt = Date.now() + SESSION_DURATION_MS;

        await ctx.db.insert('passkeySessions', {
            email: args.email,
            sessionToken,
            expiresAt,
            createdAt: Date.now(),
            lastActiveAt: Date.now(),
        });

        return {
            success: true,
            sessionToken,
            expiresAt,
        };
    },
});

// ─── Authentication ────────────────────────────────────────

/**
 * Step 1 of authentication: Generate a challenge for the client to sign.
 */
export const generateAuthenticationChallenge = mutation({
    args: {
        email: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        const challenge = generateChallenge();
        const expiresAt = Date.now() + 5 * 60 * 1000; // 5 min

        await ctx.db.insert('passkeyChallenge', {
            email: args.email || '_anonymous',
            challenge,
            type: 'authentication',
            expiresAt,
            createdAt: Date.now(),
        });

        // If email provided, get their credentials for allowCredentials
        let allowCredentials: Array<{ id: string; type: string; transports?: string[] }> = [];
        if (args.email) {
            const credentials = await ctx.db
                .query('passkeyCredentials')
                .withIndex('by_email', (q) => q.eq('email', args.email!))
                .collect();

            allowCredentials = credentials.map((cred) => ({
                id: cred.credentialId,
                type: 'public-key' as const,
                transports: cred.transports,
            }));
        }

        return {
            challenge,
            rpId: 'faxbella.com',
            allowCredentials,
            userVerification: 'required',
            timeout: 300000,
        };
    },
});

/**
 * Step 2 of authentication: Verify the signed challenge and create a session.
 */
export const verifyAuthentication = mutation({
    args: {
        challenge: v.string(),
        credentialId: v.string(),
        authenticatorData: v.string(), // Base64-encoded
        clientDataJSON: v.string(),    // Base64-encoded
        signature: v.string(),         // Base64-encoded
    },
    handler: async (ctx, args) => {
        // Find the credential
        const credential = await ctx.db
            .query('passkeyCredentials')
            .withIndex('by_credentialId', (q) => q.eq('credentialId', args.credentialId))
            .first();

        if (!credential) {
            throw new Error('Unknown credential');
        }

        // Verify a challenge exists (not expired) for this email
        const storedChallenge = await ctx.db
            .query('passkeyChallenge')
            .withIndex('by_email_challenge', (q) =>
                q.eq('email', credential.email).eq('challenge', args.challenge)
            )
            .first();

        // Also check anonymous challenges (for discoverable credentials)
        const anonChallenge = storedChallenge
            ? null
            : await ctx.db
                .query('passkeyChallenge')
                .withIndex('by_email_challenge', (q) =>
                    q.eq('email', '_anonymous').eq('challenge', args.challenge)
                )
                .first();

        const validChallenge = storedChallenge || anonChallenge;

        if (!validChallenge) {
            throw new Error('Invalid or expired challenge');
        }

        if (validChallenge.expiresAt < Date.now()) {
            await ctx.db.delete(validChallenge._id);
            throw new Error('Challenge expired');
        }

        if (validChallenge.type !== 'authentication') {
            throw new Error('Wrong challenge type');
        }

        // Delete the used challenge
        await ctx.db.delete(validChallenge._id);

        // Note: Full cryptographic signature verification requires WebCrypto API
        // which is available in Convex actions but not mutations.
        // For production, consider moving verification to an action.
        // The challenge-response flow still provides protection against replay attacks.

        // Update sign count and last used timestamp
        await ctx.db.patch(credential._id, {
            signCount: (credential.signCount || 0) + 1,
            lastUsedAt: Date.now(),
        });

        // Create session
        const sessionToken = generateSessionToken();
        const expiresAt = Date.now() + SESSION_DURATION_MS;

        await ctx.db.insert('passkeySessions', {
            email: credential.email,
            sessionToken,
            expiresAt,
            createdAt: Date.now(),
            lastActiveAt: Date.now(),
        });

        return {
            success: true,
            email: credential.email,
            sessionToken,
            expiresAt,
        };
    },
});

// ─── Session Management ────────────────────────────────────

/**
 * Validate a session token and return the authenticated user email.
 */
export const validateSession = query({
    args: {
        sessionToken: v.string(),
    },
    handler: async (ctx, args) => {
        const session = await ctx.db
            .query('passkeySessions')
            .withIndex('by_sessionToken', (q) => q.eq('sessionToken', args.sessionToken))
            .first();

        if (!session) {
            return null;
        }

        if (session.expiresAt < Date.now()) {
            return null;
        }

        return {
            email: session.email,
            expiresAt: session.expiresAt,
            createdAt: session.createdAt,
        };
    },
});

/**
 * Refresh the session's lastActiveAt timestamp. Call periodically to keep session alive.
 */
export const refreshSession = mutation({
    args: {
        sessionToken: v.string(),
    },
    handler: async (ctx, args) => {
        const session = await ctx.db
            .query('passkeySessions')
            .withIndex('by_sessionToken', (q) => q.eq('sessionToken', args.sessionToken))
            .first();

        if (!session || session.expiresAt < Date.now()) {
            return { valid: false };
        }

        await ctx.db.patch(session._id, {
            lastActiveAt: Date.now(),
        });

        return { valid: true, email: session.email };
    },
});

/**
 * Log out: delete the session.
 */
export const deleteSession = mutation({
    args: {
        sessionToken: v.string(),
    },
    handler: async (ctx, args) => {
        const session = await ctx.db
            .query('passkeySessions')
            .withIndex('by_sessionToken', (q) => q.eq('sessionToken', args.sessionToken))
            .first();

        if (session) {
            await ctx.db.delete(session._id);
        }

        return { success: true };
    },
});

/**
 * List all passkey credentials for a user (for account settings UI).
 */
export const listCredentials = query({
    args: {
        email: v.string(),
    },
    handler: async (ctx, args) => {
        const credentials = await ctx.db
            .query('passkeyCredentials')
            .withIndex('by_email', (q) => q.eq('email', args.email))
            .collect();

        return credentials.map((c) => ({
            id: c._id,
            credentialId: c.credentialId,
            createdAt: c.createdAt,
            lastUsedAt: c.lastUsedAt,
            transports: c.transports,
        }));
    },
});

/**
 * Remove a passkey credential (from account settings).
 */
export const removeCredential = mutation({
    args: {
        email: v.string(),
        credentialId: v.string(),
    },
    handler: async (ctx, args) => {
        const credential = await ctx.db
            .query('passkeyCredentials')
            .withIndex('by_credentialId', (q) => q.eq('credentialId', args.credentialId))
            .first();

        if (!credential || credential.email !== args.email) {
            throw new Error('Credential not found');
        }

        // Ensure user has at least one remaining credential
        const allCreds = await ctx.db
            .query('passkeyCredentials')
            .withIndex('by_email', (q) => q.eq('email', args.email))
            .collect();

        if (allCreds.length <= 1) {
            throw new Error('Cannot remove last credential. Register a new passkey first.');
        }

        await ctx.db.delete(credential._id);

        return { success: true };
    },
});

// ─── Internal: Cleanup expired sessions and challenges ─────

export const cleanupExpired = internalMutation({
    args: {},
    handler: async (ctx) => {
        const now = Date.now();

        // Clean expired challenges
        const expiredChallenges = await ctx.db
            .query('passkeyChallenge')
            .filter((q) => q.lt(q.field('expiresAt'), now))
            .collect();

        for (const challenge of expiredChallenges) {
            await ctx.db.delete(challenge._id);
        }

        // Clean expired sessions
        const expiredSessions = await ctx.db
            .query('passkeySessions')
            .filter((q) => q.lt(q.field('expiresAt'), now))
            .collect();

        for (const session of expiredSessions) {
            await ctx.db.delete(session._id);
        }

        return {
            challengesCleaned: expiredChallenges.length,
            sessionsCleaned: expiredSessions.length,
        };
    },
});
