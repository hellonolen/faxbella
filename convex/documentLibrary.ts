/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck - Types are generated by Convex at deploy time
/**
 * Document Library for FaxBella
 *
 * Persistent archive of all inbound and outbound faxes.
 * Auto-archives after fax processing. Supports search, star, tag,
 * reshare (email via EmailIt), and resend (forward via Faxbot API).
 */

import { action, internalAction, internalMutation, internalQuery, mutation, query } from './_generated/server';
import { internal } from './_generated/api';
import { v } from 'convex/values';

/* ─── Constants ───────────────────────────────────────── */

const DEFAULT_PAGE_SIZE = 25;
const MAX_PAGE_SIZE = 100;
const EMAILIT_ENDPOINT = 'https://api.emailit.com/v1/emails';
const FROM_ADDRESS = 'FaxBella <notifications@faxbella.com>';

/* ─── Auth Helper ─────────────────────────────────────── */

async function resolveCustomerFromSession(
    ctx: { db: any },
    sessionToken: string,
): Promise<{ customerId: any; email: string } | null> {
    const session = await ctx.db
        .query('passkeySessions')
        .withIndex('by_sessionToken', (q: any) => q.eq('sessionToken', sessionToken))
        .first();

    if (!session || session.expiresAt < Date.now()) {
        return null;
    }

    const customer = await ctx.db
        .query('customers')
        .withIndex('by_email', (q: any) => q.eq('email', session.email))
        .first();

    if (!customer) {
        return null;
    }

    return { customerId: customer._id, email: session.email };
}

/* ─── Internal: Auto-Archive Document ─────────────────── */

/**
 * Called after inbound/outbound fax processing to automatically
 * archive the document into the customer's library.
 */
export const archiveDocument = internalMutation({
    args: {
        customerId: v.id('customers'),
        sourceType: v.string(),
        sourceFaxId: v.string(),
        title: v.string(),
        documentType: v.optional(v.string()),
        fromNumber: v.optional(v.string()),
        toNumber: v.optional(v.string()),
        numPages: v.optional(v.number()),
        extractedText: v.optional(v.string()),
        storageId: v.optional(v.id('_storage')),
        r2ObjectKey: v.optional(v.string()),
        fileName: v.optional(v.string()),
        fileSize: v.optional(v.number()),
        mimeType: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        const now = Date.now();

        return await ctx.db.insert('documentLibrary', {
            customerId: args.customerId,
            sourceType: args.sourceType,
            sourceFaxId: args.sourceFaxId,
            title: args.title,
            documentType: args.documentType,
            fromNumber: args.fromNumber,
            toNumber: args.toNumber,
            numPages: args.numPages,
            extractedText: args.extractedText,
            storageId: args.storageId,
            r2ObjectKey: args.r2ObjectKey,
            fileName: args.fileName,
            fileSize: args.fileSize,
            mimeType: args.mimeType,
            starred: false,
            tags: [],
            archivedAt: now,
            createdAt: now,
        });
    },
});

/* ─── Query: List Documents (Paginated + Filtered) ────── */

export const listDocuments = query({
    args: {
        sessionToken: v.string(),
        documentType: v.optional(v.string()),
        starred: v.optional(v.boolean()),
        sourceType: v.optional(v.string()),
        tag: v.optional(v.string()),
        limit: v.optional(v.number()),
        cursor: v.optional(v.number()), // createdAt timestamp for cursor-based pagination
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            return { documents: [], hasMore: false };
        }

        const limit = Math.min(args.limit || DEFAULT_PAGE_SIZE, MAX_PAGE_SIZE);

        // Select the most specific index
        let docsQuery;

        if (args.documentType) {
            docsQuery = ctx.db
                .query('documentLibrary')
                .withIndex('by_customer_type', (q: any) =>
                    q.eq('customerId', auth.customerId).eq('documentType', args.documentType),
                );
        } else if (args.starred === true) {
            docsQuery = ctx.db
                .query('documentLibrary')
                .withIndex('by_customer_starred', (q: any) =>
                    q.eq('customerId', auth.customerId).eq('starred', true),
                );
        } else {
            docsQuery = ctx.db
                .query('documentLibrary')
                .withIndex('by_customer', (q: any) =>
                    q.eq('customerId', auth.customerId),
                );
        }

        let results = await docsQuery.order('desc').take(limit + 1);

        // Client-side filters for fields not covered by indexes
        if (args.sourceType) {
            results = results.filter((d: any) => d.sourceType === args.sourceType);
        }
        if (args.tag) {
            results = results.filter((d: any) => d.tags.includes(args.tag));
        }

        const hasMore = results.length > limit;
        const documents = results.slice(0, limit).map((doc: any) => ({
            id: doc._id,
            sourceType: doc.sourceType,
            sourceFaxId: doc.sourceFaxId,
            title: doc.title,
            documentType: doc.documentType,
            fromNumber: doc.fromNumber,
            toNumber: doc.toNumber,
            numPages: doc.numPages,
            starred: doc.starred,
            tags: doc.tags,
            r2ObjectKey: doc.r2ObjectKey,
            fileName: doc.fileName,
            fileSize: doc.fileSize,
            mimeType: doc.mimeType,
            hasFile: !!(doc.r2ObjectKey || doc.storageId),
            archivedAt: doc.archivedAt,
            createdAt: doc.createdAt,
        }));

        return { documents, hasMore };
    },
});

/* ─── Query: Full-Text Search ─────────────────────────── */

export const searchDocuments = query({
    args: {
        sessionToken: v.string(),
        searchQuery: v.string(),
        limit: v.optional(v.number()),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            return { documents: [] };
        }

        const limit = Math.min(args.limit || DEFAULT_PAGE_SIZE, MAX_PAGE_SIZE);

        const results = await ctx.db
            .query('documentLibrary')
            .withSearchIndex('search_text', (q: any) =>
                q.search('extractedText', args.searchQuery).eq('customerId', auth.customerId),
            )
            .take(limit);

        const documents = results.map((doc: any) => ({
            id: doc._id,
            sourceType: doc.sourceType,
            sourceFaxId: doc.sourceFaxId,
            title: doc.title,
            documentType: doc.documentType,
            fromNumber: doc.fromNumber,
            toNumber: doc.toNumber,
            numPages: doc.numPages,
            starred: doc.starred,
            tags: doc.tags,
            r2ObjectKey: doc.r2ObjectKey,
            fileName: doc.fileName,
            hasFile: !!(doc.r2ObjectKey || doc.storageId),
            archivedAt: doc.archivedAt,
            createdAt: doc.createdAt,
        }));

        return { documents };
    },
});

/* ─── Query: Get Single Document ──────────────────────── */

export const getDocument = query({
    args: {
        sessionToken: v.string(),
        documentId: v.id('documentLibrary'),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            return null;
        }

        const doc = await ctx.db.get(args.documentId);
        if (!doc || doc.customerId !== auth.customerId) {
            return null;
        }

        return {
            id: doc._id,
            sourceType: doc.sourceType,
            sourceFaxId: doc.sourceFaxId,
            title: doc.title,
            documentType: doc.documentType,
            fromNumber: doc.fromNumber,
            toNumber: doc.toNumber,
            numPages: doc.numPages,
            extractedText: doc.extractedText,
            starred: doc.starred,
            tags: doc.tags,
            storageId: doc.storageId ? String(doc.storageId) : undefined,
            r2ObjectKey: doc.r2ObjectKey,
            fileName: doc.fileName,
            fileSize: doc.fileSize,
            mimeType: doc.mimeType,
            hasFile: !!(doc.r2ObjectKey || doc.storageId),
            archivedAt: doc.archivedAt,
            createdAt: doc.createdAt,
        };
    },
});

/* ─── Mutation: Toggle Star ───────────────────────────── */

export const starDocument = mutation({
    args: {
        sessionToken: v.string(),
        documentId: v.id('documentLibrary'),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            throw new Error('Authentication required');
        }

        const doc = await ctx.db.get(args.documentId);
        if (!doc || doc.customerId !== auth.customerId) {
            throw new Error('Document not found');
        }

        await ctx.db.patch(args.documentId, { starred: !doc.starred });

        return { starred: !doc.starred };
    },
});

/* ─── Mutation: Add/Remove Tags ───────────────────────── */

export const tagDocument = mutation({
    args: {
        sessionToken: v.string(),
        documentId: v.id('documentLibrary'),
        action: v.union(v.literal('add'), v.literal('remove')),
        tagName: v.string(),
    },
    handler: async (ctx, args) => {
        const auth = await resolveCustomerFromSession(ctx, args.sessionToken);
        if (!auth) {
            throw new Error('Authentication required');
        }

        const doc = await ctx.db.get(args.documentId);
        if (!doc || doc.customerId !== auth.customerId) {
            throw new Error('Document not found');
        }

        const normalizedTag = args.tagName.trim().toLowerCase();
        if (!normalizedTag) {
            throw new Error('Tag name cannot be empty');
        }

        let updatedTags: string[];

        if (args.action === 'add') {
            if (doc.tags.includes(normalizedTag)) {
                return { tags: doc.tags };
            }
            updatedTags = [...doc.tags, normalizedTag];
        } else {
            updatedTags = doc.tags.filter((t: string) => t !== normalizedTag);
        }

        await ctx.db.patch(args.documentId, { tags: updatedTags });

        return { tags: updatedTags };
    },
});

/* ─── Action: Reshare Document via Email (EmailIt) ────── */

export const reshareDocument = action({
    args: {
        sessionToken: v.string(),
        documentId: v.id('documentLibrary'),
        recipientEmail: v.string(),
        message: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        // Validate session via internal query
        const session = await ctx.runQuery(internal.documentLibrary.getSessionForAction, {
            sessionToken: args.sessionToken,
        });
        if (!session) {
            throw new Error('Authentication required');
        }

        const doc = await ctx.runQuery(internal.documentLibrary.getDocumentForAction, {
            documentId: args.documentId,
            customerId: session.customerId,
        });
        if (!doc) {
            throw new Error('Document not found or access denied');
        }

        // Generate a download URL if we have an R2 key
        let downloadUrl: string | undefined;
        if (doc.r2ObjectKey) {
            const urlResult = await ctx.runAction(internal.r2.getPresignedDownloadUrlInternal, {
                objectKey: doc.r2ObjectKey,
            });
            downloadUrl = urlResult.downloadUrl;
        }

        // Send email via EmailIt
        const emailitKey = process.env.EMAILIT_API_KEY;
        if (!emailitKey) {
            throw new Error('Email service not configured');
        }

        const safeTitle = doc.title.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        const safeMessage = args.message
            ? args.message.replace(/</g, '&lt;').replace(/>/g, '&gt;')
            : '';

        const downloadLink = downloadUrl
            ? `<p style="margin:16px 0;"><a href="${downloadUrl}" style="display:inline-block;background-color:#e8553d;color:#ffffff;padding:12px 24px;border-radius:8px;text-decoration:none;font-weight:600;">Download Document</a></p>`
            : '<p style="margin:16px 0;color:#64748b;">No file attachment available for this document.</p>';

        const html = `<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8" /></head>
<body style="margin:0;padding:24px;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background-color:#f5f5f5;">
<table width="600" style="max-width:600px;margin:0 auto;background:#fff;border-radius:12px;overflow:hidden;box-shadow:0 2px 8px rgba(0,0,0,0.08);">
<tr><td style="background:linear-gradient(135deg,#2563eb,#3b82f6);padding:24px;text-align:center;">
<h1 style="margin:0;color:#fff;font-size:20px;">Shared Document</h1>
</td></tr>
<tr><td style="padding:24px;">
<h2 style="margin:0 0 8px;font-size:18px;color:#1a1a1a;">${safeTitle}</h2>
${safeMessage ? `<p style="margin:8px 0 16px;color:#475569;line-height:1.6;">${safeMessage}</p>` : ''}
${downloadLink}
<p style="margin:24px 0 0;color:#94a3b8;font-size:12px;">Shared via FaxBella</p>
</td></tr>
</table>
</body></html>`;

        const response = await fetch(EMAILIT_ENDPOINT, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${emailitKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                from: FROM_ADDRESS,
                to: args.recipientEmail,
                subject: `Shared document: ${doc.title}`,
                html,
            }),
        });

        if (!response.ok) {
            const body = await response.text();
            throw new Error(`Failed to send email: ${response.status} - ${body}`);
        }

        return { success: true };
    },
});

/* ─── Action: Resend Document as Fax (Faxbot API) ────── */

export const resendDocument = action({
    args: {
        sessionToken: v.string(),
        documentId: v.id('documentLibrary'),
        recipientNumber: v.string(),
        recipientName: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        // Validate session
        const session = await ctx.runQuery(internal.documentLibrary.getSessionForAction, {
            sessionToken: args.sessionToken,
        });
        if (!session) {
            throw new Error('Authentication required');
        }

        const doc = await ctx.runQuery(internal.documentLibrary.getDocumentForAction, {
            documentId: args.documentId,
            customerId: session.customerId,
        });
        if (!doc) {
            throw new Error('Document not found or access denied');
        }

        if (!doc.r2ObjectKey) {
            throw new Error('No file attached to this document');
        }

        // Download PDF from R2
        const base64Data = await ctx.runAction(internal.r2.downloadToBuffer, {
            objectKey: doc.r2ObjectKey,
        });

        // Send via Faxbot API
        const faxbotApiUrl = process.env.FAXBOT_API_URL;
        const faxbotApiKey = process.env.FAXBOT_API_KEY;

        if (!faxbotApiUrl || !faxbotApiKey) {
            throw new Error('Fax sending service not configured');
        }

        const response = await fetch(`${faxbotApiUrl}/send`, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${faxbotApiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                to: args.recipientNumber,
                toName: args.recipientName,
                document: base64Data,
                documentType: 'application/pdf',
                subject: doc.title,
            }),
        });

        if (!response.ok) {
            const body = await response.text();
            throw new Error(`Fax sending failed: ${response.status} - ${body}`);
        }

        const result = await response.json();

        return { success: true, faxId: result.faxId || result.id };
    },
});

/* ─── Internal Queries for Actions ────────────────────── */

export const getSessionForAction = internalQuery({
    args: { sessionToken: v.string() },
    handler: async (ctx, args) => {
        const session = await ctx.db
            .query('passkeySessions')
            .withIndex('by_sessionToken', (q: any) => q.eq('sessionToken', args.sessionToken))
            .first();

        if (!session || session.expiresAt < Date.now()) {
            return null;
        }

        const customer = await ctx.db
            .query('customers')
            .withIndex('by_email', (q: any) => q.eq('email', session.email))
            .first();

        if (!customer) {
            return null;
        }

        return { customerId: customer._id, email: session.email };
    },
});

export const getDocumentForAction = internalQuery({
    args: {
        documentId: v.id('documentLibrary'),
        customerId: v.id('customers'),
    },
    handler: async (ctx, args) => {
        const doc = await ctx.db.get(args.documentId);
        if (!doc || doc.customerId !== args.customerId) {
            return null;
        }

        return {
            title: doc.title,
            r2ObjectKey: doc.r2ObjectKey,
            fileName: doc.fileName,
            mimeType: doc.mimeType,
        };
    },
});

/* ─── Retention Policy Enforcement ───────────────────── */

/**
 * Retention policy constants per plan tier.
 * Day Pass: 30 days retention
 * Membership: 730 days (2 years) retention
 */
const RETENTION_DAYS: Record<string, number> = {
    daypass: 30,
    standard: 730,
    starter: 730,
    business: 730,
    enterprise: 730,
};

/**
 * Purge expired documents for a single customer.
 * Called by enforceRetentionPolicy.
 */
export const purgeExpiredDocuments = internalMutation({
    args: {
        customerId: v.id('customers'),
        retentionDays: v.number(),
    },
    handler: async (ctx, args) => {
        const cutoff = Date.now() - (args.retentionDays * 24 * 60 * 60 * 1000);

        const expiredDocs = await ctx.db
            .query('documentLibrary')
            .withIndex('by_customer', (q) => q.eq('customerId', args.customerId))
            .collect();

        let purged = 0;
        for (const doc of expiredDocs) {
            if (doc.archivedAt < cutoff) {
                await ctx.db.delete(doc._id);
                purged++;
            }
        }

        return { purged };
    },
});

/**
 * Daily cron job: enforce document retention per customer's plan.
 * Sends a warning email 7 days before purge for the oldest documents.
 */
export const enforceRetentionPolicy = internalAction({
    args: {},
    handler: async (ctx) => {
        const customers = await ctx.runQuery(internal.documentLibrary.getAllCustomersForRetention, {});

        let totalPurged = 0;
        for (const customer of customers) {
            const retentionDays = RETENTION_DAYS[customer.plan?.toLowerCase()] || 730;
            const result = await ctx.runMutation(internal.documentLibrary.purgeExpiredDocuments, {
                customerId: customer._id,
                retentionDays,
            });
            totalPurged += result.purged;
        }

        if (totalPurged > 0) {
            console.log(`[RETENTION] Purged ${totalPurged} expired documents`);
        }
    },
});

/**
 * Internal query: get all active customers with their plan info for retention checks.
 */
export const getAllCustomersForRetention = internalQuery({
    args: {},
    handler: async (ctx) => {
        const customers = await ctx.db.query('customers').collect();
        return customers.map((c) => ({
            _id: c._id,
            email: c.email,
            plan: c.plan,
        }));
    },
});
