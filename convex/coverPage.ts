/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck - Types are generated by Convex at deploy time
/**
 * Cover Page Generation & PDF Merging
 *
 * Generates professional fax cover pages using pdf-lib and merges them
 * with attachment PDFs for outbound fax transmission via HumbleFax.
 */

import { internalAction } from './_generated/server';
import { v } from 'convex/values';
import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';

// -- Layout Constants --

const PAGE_WIDTH = 612;
const PAGE_HEIGHT = 792;

const HEADER_HEIGHT = 60;
const ACCENT_LINE_HEIGHT = 3;

const MARGIN_LEFT = 50;
const MARGIN_RIGHT = 50;
const CONTENT_WIDTH = PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT;

const BRAND_NAME = 'FaxBella';
const BRAND_DOMAIN = 'faxbella.com';

// Colors
const COLOR_HEADER_BG = rgb(0.173, 0.173, 0.173);       // #2c2c2c
const COLOR_ACCENT = rgb(0.910, 0.333, 0.239);           // #e8553d
const COLOR_WHITE = rgb(1, 1, 1);
const COLOR_BLACK = rgb(0, 0, 0);
const COLOR_LABEL = rgb(0.5, 0.5, 0.5);                  // Gray for labels
const COLOR_MESSAGE_BG = rgb(0.961, 0.961, 0.961);       // #f5f5f5
const COLOR_FOOTER = rgb(0.6, 0.6, 0.6);                 // Light gray for footer text
const COLOR_CONFIDENTIALITY = rgb(0.55, 0.55, 0.55);

// Font sizes (in points)
const FONT_SIZE_BRAND = 24;
const FONT_SIZE_LABEL = 10;
const FONT_SIZE_NAME = 16;
const FONT_SIZE_NUMBER = 12;
const FONT_SIZE_SUBJECT = 14;
const FONT_SIZE_MESSAGE = 12;
const FONT_SIZE_PAGE_COUNT = 11;
const FONT_SIZE_CONFIDENTIALITY = 8;
const FONT_SIZE_FOOTER = 8;

const MESSAGE_MAX_CHARS = 500;
const MESSAGE_CHARS_PER_LINE = 70;
const MESSAGE_LINE_HEIGHT = 16;
const MESSAGE_BOX_PADDING = 16;

// -- Helpers --

/**
 * Word-wraps text into lines that fit within maxCharsPerLine.
 * Handles words longer than the limit by force-breaking them.
 */
function wrapText(text: string, maxCharsPerLine: number): string[] {
    const lines: string[] = [];
    const paragraphs = text.split('\n');

    for (const paragraph of paragraphs) {
        if (paragraph.trim() === '') {
            lines.push('');
            continue;
        }

        const words = paragraph.split(/\s+/);
        let currentLine = '';

        for (const word of words) {
            if (word.length > maxCharsPerLine) {
                // Flush current line if it has content
                if (currentLine.length > 0) {
                    lines.push(currentLine);
                    currentLine = '';
                }
                // Force-break the long word
                let remaining = word;
                while (remaining.length > maxCharsPerLine) {
                    lines.push(remaining.slice(0, maxCharsPerLine));
                    remaining = remaining.slice(maxCharsPerLine);
                }
                if (remaining.length > 0) {
                    currentLine = remaining;
                }
            } else if (currentLine.length === 0) {
                currentLine = word;
            } else if (currentLine.length + 1 + word.length <= maxCharsPerLine) {
                currentLine += ' ' + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }

        if (currentLine.length > 0) {
            lines.push(currentLine);
        }
    }

    return lines;
}

/**
 * Formats a timestamp as "Month DD, YYYY at HH:MM AM/PM".
 */
function formatDateTime(date: Date): string {
    const months = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December',
    ];

    const month = months[date.getMonth()];
    const day = date.getDate();
    const year = date.getFullYear();

    let hours = date.getHours();
    const minutes = date.getMinutes().toString().padStart(2, '0');
    const ampm = hours >= 12 ? 'PM' : 'AM';
    hours = hours % 12 || 12;

    return `${month} ${day}, ${year} at ${hours}:${minutes} ${ampm}`;
}

// -- Internal Actions --

/**
 * Generates a professional fax cover page PDF.
 *
 * Returns a base64-encoded PDF buffer containing a single US Letter page
 * with branded header, sender/recipient info, optional message, and
 * confidentiality notice.
 */
export const generateCoverPage = internalAction({
    args: {
        customerName: v.string(),
        customerNumber: v.optional(v.string()),
        recipientName: v.string(),
        recipientNumber: v.string(),
        subject: v.optional(v.string()),
        message: v.optional(v.string()),
        pageCount: v.optional(v.number()),
    },
    handler: async (_ctx, args) => {
        try {
            const pdfDoc = await PDFDocument.create();
            const page = pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);

            const fontBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
            const fontRegular = await pdfDoc.embedFont(StandardFonts.Helvetica);

            // -- Header bar: full width, dark background, centered brand name --
            const headerY = PAGE_HEIGHT - HEADER_HEIGHT;
            page.drawRectangle({
                x: 0,
                y: headerY,
                width: PAGE_WIDTH,
                height: HEADER_HEIGHT,
                color: COLOR_HEADER_BG,
            });

            const brandWidth = fontBold.widthOfTextAtSize(BRAND_NAME, FONT_SIZE_BRAND);
            page.drawText(BRAND_NAME, {
                x: (PAGE_WIDTH - brandWidth) / 2,
                y: headerY + (HEADER_HEIGHT - FONT_SIZE_BRAND) / 2,
                size: FONT_SIZE_BRAND,
                font: fontBold,
                color: COLOR_WHITE,
            });

            // -- Accent line --
            const accentY = headerY - ACCENT_LINE_HEIGHT;
            page.drawRectangle({
                x: 0,
                y: accentY,
                width: PAGE_WIDTH,
                height: ACCENT_LINE_HEIGHT,
                color: COLOR_ACCENT,
            });

            // -- FROM section (y: ~680) --
            const fromSectionY = 680;
            page.drawText('FROM', {
                x: MARGIN_LEFT,
                y: fromSectionY,
                size: FONT_SIZE_LABEL,
                font: fontBold,
                color: COLOR_LABEL,
            });

            page.drawText(args.customerName, {
                x: MARGIN_LEFT,
                y: fromSectionY - 18,
                size: FONT_SIZE_NAME,
                font: fontBold,
                color: COLOR_BLACK,
            });

            if (args.customerNumber) {
                page.drawText(args.customerNumber, {
                    x: MARGIN_LEFT,
                    y: fromSectionY - 34,
                    size: FONT_SIZE_NUMBER,
                    font: fontRegular,
                    color: COLOR_BLACK,
                });
            }

            // -- TO section (y: ~620) --
            const toSectionY = 620;
            page.drawText('TO', {
                x: MARGIN_LEFT,
                y: toSectionY,
                size: FONT_SIZE_LABEL,
                font: fontBold,
                color: COLOR_LABEL,
            });

            page.drawText(args.recipientName, {
                x: MARGIN_LEFT,
                y: toSectionY - 18,
                size: FONT_SIZE_NAME,
                font: fontBold,
                color: COLOR_BLACK,
            });

            page.drawText(args.recipientNumber, {
                x: MARGIN_LEFT,
                y: toSectionY - 34,
                size: FONT_SIZE_NUMBER,
                font: fontRegular,
                color: COLOR_BLACK,
            });

            // -- DATE section (y: ~560) --
            const dateSectionY = 560;
            page.drawText('DATE', {
                x: MARGIN_LEFT,
                y: dateSectionY,
                size: FONT_SIZE_LABEL,
                font: fontBold,
                color: COLOR_LABEL,
            });

            const dateStr = formatDateTime(new Date());
            page.drawText(dateStr, {
                x: MARGIN_LEFT,
                y: dateSectionY - 18,
                size: FONT_SIZE_NUMBER,
                font: fontRegular,
                color: COLOR_BLACK,
            });

            // -- SUBJECT section (y: ~510) --
            const subjectSectionY = 510;
            page.drawText('SUBJECT', {
                x: MARGIN_LEFT,
                y: subjectSectionY,
                size: FONT_SIZE_LABEL,
                font: fontBold,
                color: COLOR_LABEL,
            });

            const subjectText = args.subject || 'N/A';
            const subjectFont = args.subject ? fontBold : fontRegular;
            page.drawText(subjectText, {
                x: MARGIN_LEFT,
                y: subjectSectionY - 18,
                size: FONT_SIZE_SUBJECT,
                font: subjectFont,
                color: COLOR_BLACK,
            });

            // -- PAGE COUNT (y: ~470) --
            const pageCountSectionY = 470;
            const totalPages = args.pageCount ?? 1;
            page.drawText(`Pages (including cover): ${totalPages}`, {
                x: MARGIN_LEFT,
                y: pageCountSectionY,
                size: FONT_SIZE_PAGE_COUNT,
                font: fontRegular,
                color: COLOR_BLACK,
            });

            // -- Message section (y: ~420) --
            if (args.message && args.message.trim().length > 0) {
                const messageSectionY = 420;
                const truncatedMessage = args.message.slice(0, MESSAGE_MAX_CHARS);
                const messageLines = wrapText(truncatedMessage, MESSAGE_CHARS_PER_LINE);

                const messageBoxHeight =
                    (messageLines.length * MESSAGE_LINE_HEIGHT) + (MESSAGE_BOX_PADDING * 2);

                // Light gray background box
                page.drawRectangle({
                    x: MARGIN_LEFT,
                    y: messageSectionY - messageBoxHeight,
                    width: CONTENT_WIDTH,
                    height: messageBoxHeight,
                    color: COLOR_MESSAGE_BG,
                    borderWidth: 0,
                });

                // Draw each line of the wrapped message
                for (let i = 0; i < messageLines.length; i++) {
                    const lineY =
                        messageSectionY - MESSAGE_BOX_PADDING - (i * MESSAGE_LINE_HEIGHT);
                    page.drawText(messageLines[i], {
                        x: MARGIN_LEFT + MESSAGE_BOX_PADDING,
                        y: lineY,
                        size: FONT_SIZE_MESSAGE,
                        font: fontRegular,
                        color: COLOR_BLACK,
                    });
                }
            }

            // -- Confidentiality notice (bottom, y: ~60) --
            const confidentialityY = 60;
            const confidentialityText =
                'CONFIDENTIALITY NOTICE: This fax transmission is intended only for the named recipient. ' +
                'If you have received this in error, please notify the sender immediately and destroy all copies.';
            const confidentialityLines = wrapText(confidentialityText, 95);

            for (let i = 0; i < confidentialityLines.length; i++) {
                page.drawText(confidentialityLines[i], {
                    x: MARGIN_LEFT,
                    y: confidentialityY - (i * 10),
                    size: FONT_SIZE_CONFIDENTIALITY,
                    font: fontRegular,
                    color: COLOR_CONFIDENTIALITY,
                });
            }

            // -- Footer line --
            const footerY = 30;
            const footerText = `Powered by ${BRAND_NAME} | ${BRAND_DOMAIN}`;
            const footerWidth = fontRegular.widthOfTextAtSize(footerText, FONT_SIZE_FOOTER);
            page.drawText(footerText, {
                x: (PAGE_WIDTH - footerWidth) / 2,
                y: footerY,
                size: FONT_SIZE_FOOTER,
                font: fontRegular,
                color: COLOR_FOOTER,
            });

            // Serialize to base64
            const pdfBytes = await pdfDoc.save();
            const base64 = uint8ArrayToBase64(pdfBytes);

            return { buffer: base64 };
        } catch (error) {
            const message = error instanceof Error ? error.message : 'Unknown error';
            throw new Error(`[COVER PAGE] Failed to generate cover page: ${message}`);
        }
    },
});

/**
 * Merges a cover page PDF with an attachment PDF into a single document.
 *
 * Both inputs and the output are base64-encoded PDF buffers. The cover page
 * appears first, followed by all pages from the attachment.
 */
export const mergePDFs = internalAction({
    args: {
        coverPageBuffer: v.string(),
        attachmentBuffer: v.string(),
    },
    handler: async (_ctx, args) => {
        try {
            const coverPageBytes = base64ToUint8Array(args.coverPageBuffer);
            const attachmentBytes = base64ToUint8Array(args.attachmentBuffer);

            const coverPageDoc = await PDFDocument.load(coverPageBytes);
            const attachmentDoc = await PDFDocument.load(attachmentBytes);

            const mergedDoc = await PDFDocument.create();

            // Copy all cover page pages (typically 1)
            const coverPages = await mergedDoc.copyPages(
                coverPageDoc,
                coverPageDoc.getPageIndices(),
            );
            for (const page of coverPages) {
                mergedDoc.addPage(page);
            }

            // Copy all attachment pages
            const attachmentPages = await mergedDoc.copyPages(
                attachmentDoc,
                attachmentDoc.getPageIndices(),
            );
            for (const page of attachmentPages) {
                mergedDoc.addPage(page);
            }

            const mergedBytes = await mergedDoc.save();
            const base64 = uint8ArrayToBase64(mergedBytes);

            return { mergedBuffer: base64 };
        } catch (error) {
            const message = error instanceof Error ? error.message : 'Unknown error';
            throw new Error(`[COVER PAGE] Failed to merge PDFs: ${message}`);
        }
    },
});

// -- Base64 Encoding/Decoding Utilities --

/**
 * Converts a Uint8Array to a base64-encoded string.
 * Uses chunked processing to avoid call stack overflow on large buffers.
 */
function uint8ArrayToBase64(bytes: Uint8Array): string {
    const CHUNK_SIZE = 8192;
    let binary = '';
    for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {
        const chunk = bytes.subarray(i, i + CHUNK_SIZE);
        binary += String.fromCharCode(...chunk);
    }
    return btoa(binary);
}

/**
 * Converts a base64-encoded string back to a Uint8Array.
 */
function base64ToUint8Array(base64: string): Uint8Array {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}
