/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck - Types are generated by Convex at deploy time
/**
 * AI-Powered Fax Routing for SaaS Customers
 * 
 * This is the core routing engine that:
 * 1. Receives webhook from HumbleFax
 * 2. Downloads the fax PDF
 * 3. Uses Gemini AI to analyze and extract recipient info
 * 4. Matches to a registered recipient
 * 5. Delivers via EmailIt (NEVER use Resend or other email providers)
 */

import { internalAction, internalMutation, internalQuery } from './_generated/server';
import { v } from 'convex/values';
import { internal } from './_generated/api';

// Store incoming fax for processing
export const storeInboundFax = internalMutation({
    args: {
        customerId: v.id('customers'),
        providerFaxId: v.string(),
        fromNumber: v.string(),
        toNumber: v.string(),
        numPages: v.number(),
    },
    handler: async (ctx, args) => {
        const now = Date.now();
        return await ctx.db.insert('inboundFaxes', {
            customerId: args.customerId,
            providerFaxId: args.providerFaxId,
            fromNumber: args.fromNumber,
            toNumber: args.toNumber,
            numPages: args.numPages,
            status: 'pending',
            receivedAt: now,
            createdAt: now,
        });
    },
});

// Update fax after processing (enhanced with competitor-inspired fields)
export const updateInboundFax = internalMutation({
    args: {
        id: v.id('inboundFaxes'),
        status: v.optional(v.string()),
        routedToRecipientId: v.optional(v.id('recipients')),
        routingConfidence: v.optional(v.number()),
        routingReason: v.optional(v.string()),
        extractedText: v.optional(v.string()),
        storageId: v.optional(v.id('_storage')),
        r2ObjectKey: v.optional(v.string()),
        fileName: v.optional(v.string()),
        fileSize: v.optional(v.number()),
        mimeType: v.optional(v.string()),
        error: v.optional(v.string()),
        // Enhanced AI extraction fields
        documentType: v.optional(v.string()),
        urgency: v.optional(v.string()),
        urgencyReason: v.optional(v.string()),
        structuredData: v.optional(v.any()), // Complex object
        // Webhook delivery
        webhookDelivered: v.optional(v.boolean()),
        webhookDeliveredAt: v.optional(v.number()),
        webhookResponse: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        const { id, ...patch } = args;
        const updates: Record<string, unknown> = { processedAt: Date.now() };

        if (patch.status !== undefined) updates.status = patch.status;
        if (patch.routedToRecipientId !== undefined) updates.routedToRecipientId = patch.routedToRecipientId;
        if (patch.routingConfidence !== undefined) updates.routingConfidence = patch.routingConfidence;
        if (patch.routingReason !== undefined) updates.routingReason = patch.routingReason;
        if (patch.extractedText !== undefined) updates.extractedText = patch.extractedText;
        if (patch.storageId !== undefined) updates.storageId = patch.storageId;
        if (patch.r2ObjectKey !== undefined) updates.r2ObjectKey = patch.r2ObjectKey;
        if (patch.fileName !== undefined) updates.fileName = patch.fileName;
        if (patch.fileSize !== undefined) updates.fileSize = patch.fileSize;
        if (patch.mimeType !== undefined) updates.mimeType = patch.mimeType;
        if (patch.error !== undefined) updates.error = patch.error;
        // Enhanced fields
        if (patch.documentType !== undefined) updates.documentType = patch.documentType;
        if (patch.urgency !== undefined) updates.urgency = patch.urgency;
        if (patch.urgencyReason !== undefined) updates.urgencyReason = patch.urgencyReason;
        if (patch.structuredData !== undefined) updates.structuredData = patch.structuredData;
        if (patch.webhookDelivered !== undefined) updates.webhookDelivered = patch.webhookDelivered;
        if (patch.webhookDeliveredAt !== undefined) updates.webhookDeliveredAt = patch.webhookDeliveredAt;
        if (patch.webhookResponse !== undefined) updates.webhookResponse = patch.webhookResponse;

        await ctx.db.patch(id, updates);
    },
});

// Increment customer's monthly fax count
export const incrementFaxCount = internalMutation({
    args: {
        customerId: v.id('customers'),
    },
    handler: async (ctx, args) => {
        const customer = await ctx.db.get(args.customerId);
        if (!customer) return;

        await ctx.db.patch(args.customerId, {
            faxesThisMonth: (customer.faxesThisMonth || 0) + 1,
            updatedAt: Date.now(),
        });
    },
});

// Get customer by webhook secret
export const getCustomerByWebhookSecret = internalQuery({
    args: {
        webhookSecret: v.string(),
    },
    handler: async (ctx, args) => {
        return await ctx.db
            .query('customers')
            .withIndex('by_webhookSecret', (q) => q.eq('webhookSecret', args.webhookSecret))
            .first();
    },
});

// Get customer by ID
export const getCustomerById = internalQuery({
    args: { customerId: v.id('customers') },
    handler: async (ctx, args) => {
        return await ctx.db.get(args.customerId);
    },
});

// Get recipients for a customer
export const getRecipientsForCustomer = internalQuery({
    args: {
        customerId: v.id('customers'),
    },
    handler: async (ctx, args) => {
        return await ctx.db
            .query('recipients')
            .withIndex('by_customer', (q) => q.eq('customerId', args.customerId))
            .filter((q) => q.eq(q.field('active'), true))
            .collect();
    },
});

// Main AI routing action
export const processInboundFaxWithAI = internalAction({
    args: {
        inboundFaxId: v.id('inboundFaxes'),
        customerId: v.id('customers'),
        providerFaxId: v.string(),
        fromNumber: v.string(),
    },
    handler: async (ctx, args) => {
        // Get customer's credentials or use platform defaults
        const customer = await ctx.runQuery(internal.faxRouting.getCustomerById, {
            customerId: args.customerId,
        });

        // Get HumbleFax credentials (customer's or platform's)
        const accessKey = customer?.humbleFaxAccessKey || process.env.HUMBLEFAX_ACCESS_KEY;
        const secretKey = customer?.humbleFaxSecretKey || process.env.HUMBLEFAX_SECRET_KEY;
        const geminiKey = customer?.geminiApiKey || process.env.GEMINI_API_KEY;

        if (!accessKey || !secretKey) {
            await ctx.runMutation(internal.faxRouting.updateInboundFax, {
                id: args.inboundFaxId,
                status: 'error',
                error: 'Fax credentials not configured',
            });
            return { success: false, error: 'Fax credentials not configured' };
        }

        if (!geminiKey) {
            await ctx.runMutation(internal.faxRouting.updateInboundFax, {
                id: args.inboundFaxId,
                status: 'error',
                error: 'AI API key not configured',
            });
            return { success: false, error: 'AI API key not configured' };
        }

        try {
            // Step 1: Download the fax PDF from HumbleFax
            const authHeader = 'Basic ' + btoa(`${accessKey}:${secretKey}`);
            const downloadResponse = await fetch(
                `https://api.humblefax.com/incomingFax/${args.providerFaxId}/download`,
                { headers: { Authorization: authHeader } }
            );

            if (!downloadResponse.ok) {
                throw new Error(`Failed to download fax: ${downloadResponse.status}`);
            }

            const pdfBuffer = await downloadResponse.arrayBuffer();
            // Chunked base64 conversion to avoid stack overflow on large faxes
            const bytes = new Uint8Array(pdfBuffer);
            const CHUNK = 8192;
            let pdfBase64 = '';
            for (let i = 0; i < bytes.length; i += CHUNK) {
                pdfBase64 += String.fromCharCode(...bytes.subarray(i, i + CHUNK));
            }
            pdfBase64 = btoa(pdfBase64);

            // Step 2: Get all recipients for matching
            const recipients = await ctx.runQuery(internal.faxRouting.getRecipientsForCustomer, {
                customerId: args.customerId,
            });

            // Step 3: Use Gemini to OCR and analyze the fax with ENHANCED extraction
            // Inspired by: Concord, eFax Clarity, ETHERFAX AI Insights, Phelix AI, Medsender AI
            const recipientList = recipients.map(r =>
                `- ${r.name} (${r.email})${r.company ? ` - Company: ${r.company}` : ''}${r.keywords?.length ? ` - Keywords: ${r.keywords.join(', ')}` : ''}`
            ).join('\n');

            const prompt = `You are an advanced AI fax analysis system for FaxBella. Analyze this incoming fax with comprehensive data extraction.

REGISTERED RECIPIENTS:
${recipientList}

INCOMING FAX FROM: ${args.fromNumber}

PERFORM THE FOLLOWING ANALYSIS:

1. **OCR EXTRACTION**: Extract ALL text from the fax document.

2. **DOCUMENT CLASSIFICATION** (like Medsender AI):
   Classify as one of: referral, prescription_refill, lab_results, invoice, prior_auth, medical_records, insurance_claim, appointment_request, test_results, discharge_summary, consultation_notes, other

3. **URGENCY DETECTION** (like Phelix AI):
   Determine urgency level:
   - "urgent": STAT, ASAP, Emergency, Critical, Urgent marked, time-sensitive procedures
   - "routine": Standard processing, no rush indicators
   - "low": Informational only, no action required
   Explain WHY if urgent.

4. **RECIPIENT ROUTING**:
   Match to the most appropriate recipient from the list above based on:
   - Explicit recipient names (To:, Attention:, ATTN:, Dear)
   - Account or reference numbers matching keywords
   - Company/organization matches
   - Specialty or department indicators

5. **STRUCTURED DATA EXTRACTION** (like Concord, eFax Clarity, ETHERFAX):
   Extract these fields if present:
   
   Patient/Contact:
   - Patient full name
   - Date of birth (DOB)
   - Phone number
   - Medical Record Number (MRN)
   
   Sender:
   - Sender name
   - Organization/Practice name
   - Phone and fax numbers
   
   Document-Specific:
   - Referral type (specialist, imaging, lab, etc.)
   - Prescription drug name
   - Invoice number and amount
   - Date of service
   
   Insurance:
   - Insurance provider name
   - Authorization number

6. **MULTI-PATIENT DETECTION** (like Phelix AI):
   If this fax contains information about MULTIPLE patients, indicate how many.

Respond in this EXACT JSON format:
{
  "extractedText": "The full OCR text...",
  "documentType": "referral|prescription_refill|lab_results|invoice|prior_auth|medical_records|insurance_claim|appointment_request|test_results|discharge_summary|consultation_notes|other",
  "urgency": "urgent|routine|low",
  "urgencyReason": "Explanation if urgent, otherwise null",
  "recipientName": "Name found in fax or null",
  "recipientCompany": "Company found or null",
  "matchedRecipientEmail": "user@email.com or null",
  "confidence": 0.0 to 1.0,
  "reason": "Why this recipient was matched",
  "structuredData": {
    "patientName": "string or null",
    "patientDOB": "MM/DD/YYYY or null",
    "patientPhone": "string or null",
    "patientMRN": "string or null",
    "senderName": "string or null",
    "senderOrganization": "string or null",
    "senderPhone": "string or null",
    "senderFax": "string or null",
    "referralType": "specialist|imaging|lab|physical_therapy|other or null",
    "prescriptionDrug": "string or null",
    "invoiceNumber": "string or null",
    "invoiceAmount": "string or null",
    "dateOfService": "MM/DD/YYYY or null",
    "insuranceProvider": "string or null",
    "authorizationNumber": "string or null"
  },
  "multiPatientCount": 1
}`;

            const geminiResponse = await fetch(
                'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent',
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-goog-api-key': geminiKey,
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [
                                { text: prompt },
                                { inline_data: { mime_type: 'application/pdf', data: pdfBase64 } }
                            ]
                        }],
                        generationConfig: {
                            temperature: 0.1,
                            topP: 0.8,
                            responseMimeType: 'application/json',
                        }
                    }),
                }
            );

            if (!geminiResponse.ok) {
                throw new Error(`AI API error: ${geminiResponse.status}`);
            }

            const geminiData = await geminiResponse.json();
            const responseText = geminiData.candidates?.[0]?.content?.parts?.[0]?.text || '{}';

            let analysis;
            try {
                analysis = JSON.parse(responseText);
            } catch {
                console.error('[FAX ROUTING] Failed to parse AI response:', responseText);
                analysis = { matchedRecipientEmail: null, confidence: 0, reason: 'Failed to parse AI response' };
            }

            console.log(`[FAX ROUTING] AI Analysis: type=${analysis.documentType}, urgency=${analysis.urgency}, confidence=${analysis.confidence}`);

            // Step 4: Find the matched recipient
            let matchedRecipient = null;
            if (analysis.matchedRecipientEmail) {
                matchedRecipient = recipients.find(r =>
                    r.email.toLowerCase() === analysis.matchedRecipientEmail.toLowerCase()
                );
            }

            // If no email match, try name match
            if (!matchedRecipient && analysis.recipientName) {
                matchedRecipient = recipients.find(r =>
                    r.name.toLowerCase().includes(analysis.recipientName.toLowerCase()) ||
                    analysis.recipientName.toLowerCase().includes(r.name.toLowerCase())
                );
            }

            if (matchedRecipient && analysis.confidence >= 0.5) {
                // Step 5: Store the fax PDF in R2 (per-account document storage)
                const faxFileName = `fax_${args.providerFaxId}_${args.fromNumber.replace(/\D/g, '')}.pdf`;
                let r2ObjectKey: string | undefined;
                let r2FileSize: number | undefined;
                try {
                    const r2Result = await ctx.runAction(internal.r2.uploadFromBuffer, {
                        customerId: String(args.customerId),
                        buffer: pdfBase64,
                        fileName: faxFileName,
                        mimeType: 'application/pdf',
                        direction: 'inbound',
                    });
                    r2ObjectKey = r2Result.objectKey;
                    r2FileSize = r2Result.fileSize;
                } catch (r2Error) {
                    console.error('[FAX ROUTING] R2 upload failed (non-fatal):', r2Error);
                }

                // Step 6: Update fax record with ENHANCED AI extraction data
                await ctx.runMutation(internal.faxRouting.updateInboundFax, {
                    id: args.inboundFaxId,
                    status: 'routed',
                    routedToRecipientId: matchedRecipient._id,
                    routingConfidence: analysis.confidence,
                    routingReason: analysis.reason,
                    extractedText: analysis.extractedText?.slice(0, 5000),
                    r2ObjectKey,
                    fileName: faxFileName,
                    fileSize: r2FileSize,
                    mimeType: 'application/pdf',
                    documentType: analysis.documentType,
                    urgency: analysis.urgency,
                    urgencyReason: analysis.urgencyReason,
                    structuredData: analysis.structuredData,
                });

                // Step 7: Increment usage
                await ctx.runMutation(internal.faxRouting.incrementFaxCount, {
                    customerId: args.customerId,
                });

                // Step 8: Send notification via centralized notifications module
                try {
                    if (customer?.email) {
                        await ctx.runAction(internal.notifications.sendFaxReceivedNotification, {
                            customerEmail: customer.email,
                            fromNumber: args.fromNumber,
                            documentType: analysis.documentType,
                            urgency: analysis.urgency,
                            urgencyReason: analysis.urgencyReason,
                            aiSummary: analysis.extractedText?.slice(0, 200),
                            faxId: String(args.inboundFaxId),
                        });
                    }
                } catch (notifError) {
                    console.error('[FAX ROUTING] Notification failed (non-fatal):', notifError);
                }

                console.log(`[FAX ROUTING] SUCCESS: Routed fax to ${matchedRecipient.email}`);

                return {
                    success: true,
                    routed: true,
                    recipientId: matchedRecipient._id,
                    confidence: analysis.confidence,
                    reason: analysis.reason,
                };
            } else {
                // Unroutable â€” still store the PDF in R2 so user can review it
                const faxFileName = `fax_${args.providerFaxId}_${args.fromNumber.replace(/\D/g, '')}.pdf`;
                let r2ObjectKey: string | undefined;
                let r2FileSize: number | undefined;
                try {
                    const r2Result = await ctx.runAction(internal.r2.uploadFromBuffer, {
                        customerId: String(args.customerId),
                        buffer: pdfBase64,
                        fileName: faxFileName,
                        mimeType: 'application/pdf',
                        direction: 'inbound',
                    });
                    r2ObjectKey = r2Result.objectKey;
                    r2FileSize = r2Result.fileSize;
                } catch (r2Error) {
                    console.error('[FAX ROUTING] R2 upload failed for unroutable fax (non-fatal):', r2Error);
                }

                await ctx.runMutation(internal.faxRouting.updateInboundFax, {
                    id: args.inboundFaxId,
                    status: 'unroutable',
                    routingConfidence: analysis.confidence || 0,
                    routingReason: analysis.reason || 'No matching recipient found',
                    extractedText: analysis.extractedText?.slice(0, 5000),
                    r2ObjectKey,
                    fileName: faxFileName,
                    fileSize: r2FileSize,
                    mimeType: 'application/pdf',
                    documentType: analysis.documentType,
                    urgency: analysis.urgency,
                    urgencyReason: analysis.urgencyReason,
                    structuredData: analysis.structuredData,
                });

                // Notify customer about unroutable fax
                try {
                    const customerData = await ctx.runQuery(internal.faxRouting.getCustomerById, {
                        customerId: args.customerId,
                    });
                    if (customerData?.email) {
                        await ctx.runAction(internal.notifications.sendFaxReceivedNotification, {
                            customerEmail: customerData.email,
                            fromNumber: args.fromNumber,
                            documentType: analysis.documentType,
                            urgency: analysis.urgency,
                            urgencyReason: analysis.urgencyReason,
                            aiSummary: analysis.extractedText?.slice(0, 200),
                            faxId: String(args.inboundFaxId),
                        });
                    }
                } catch (notifError) {
                    console.error('[FAX ROUTING] Notification for unroutable fax failed (non-fatal):', notifError);
                }

                console.log(`[FAX ROUTING] UNROUTABLE: ${analysis.reason}`);

                return {
                    success: true,
                    routed: false,
                    reason: analysis.reason || 'No matching recipient found',
                };
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            console.error('[FAX ROUTING] ERROR:', errorMessage);

            await ctx.runMutation(internal.faxRouting.updateInboundFax, {
                id: args.inboundFaxId,
                status: 'error',
                error: errorMessage,
            });

            return { success: false, error: errorMessage };
        }
    },
});
