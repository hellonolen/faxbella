/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck - Types are generated by Convex at deploy time
/**
 * Stripe Payment Integration for FaxBella
 *
 * Primary payment processor. Handles checkout sessions, billing portal,
 * and webhook event processing. Whop is the backup processor (see whop.ts).
 *
 * Environment variables (stored in Convex):
 *   STRIPE_SECRET_KEY
 *   STRIPE_WEBHOOK_SECRET
 *   STRIPE_PRICE_STARTER_MONTHLY / ANNUAL
 *   STRIPE_PRICE_BUSINESS_MONTHLY / ANNUAL
 *   STRIPE_PRICE_ENTERPRISE_MONTHLY / ANNUAL
 *   EMAILIT_API_KEY
 */

import { action, internalMutation, internalAction, internalQuery } from './_generated/server';
import { v } from 'convex/values';
import { internal } from './_generated/api';
import Stripe from 'stripe';

// ─── Constants ───────────────────────────────────────────

const PLAN_LIMITS: Record<string, { faxes: number; recipients: number }> = {
    standard: { faxes: 1000, recipients: 999999 },
    daypass: { faxes: 5, recipients: 999999 },
    // Legacy support
    starter: { faxes: 1000, recipients: 999999 },
    business: { faxes: 1000, recipients: 999999 },
    enterprise: { faxes: 1000, recipients: 999999 },
};

const VALID_PLANS = ['standard', 'daypass', 'starter', 'business', 'enterprise'];
const VALID_BILLING_CYCLES = ['monthly', 'annual'];

// ─── Helpers ─────────────────────────────────────────────

function getStripeClient(): Stripe {
    const secretKey = process.env.STRIPE_SECRET_KEY;
    if (!secretKey) {
        throw new Error('STRIPE_SECRET_KEY not configured');
    }
    return new Stripe(secretKey, { apiVersion: '2024-12-18.acacia' });
}

function getPriceId(plan: string, billingCycle: string): string {
    const key = `STRIPE_PRICE_${plan.toUpperCase()}_${billingCycle.toUpperCase()}`;
    const priceId = process.env[key];
    if (!priceId) {
        throw new Error(`Stripe price not configured: ${key}`);
    }
    return priceId;
}

function generateWebhookSecret(): string {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
    let secret = 'faxai_';
    for (let i = 0; i < 32; i++) {
        secret += chars[crypto.getRandomValues(new Uint32Array(1))[0] % chars.length];
    }
    return secret;
}

// ─── Queries ─────────────────────────────────────────────

/**
 * Internal helper to look up a customer by email.
 */
export const getCustomerByEmail = internalQuery({
    args: {
        email: v.string(),
    },
    handler: async (ctx, args) => {
        return await ctx.db
            .query('customers')
            .withIndex('by_email', (q) => q.eq('email', args.email))
            .first();
    },
});

// ─── Checkout & Portal ───────────────────────────────────

/**
 * Create a Stripe Checkout Session for a new subscription.
 * Returns the checkout URL for the frontend to redirect to.
 */
export const createCheckoutSession = action({
    args: {
        email: v.string(),
        plan: v.string(),
        billingCycle: v.string(),
        successUrl: v.string(),
        cancelUrl: v.string(),
    },
    handler: async (ctx, args) => {
        if (!VALID_PLANS.includes(args.plan)) {
            throw new Error(`Invalid plan: ${args.plan}. Must be one of: ${VALID_PLANS.join(', ')}`);
        }
        if (!VALID_BILLING_CYCLES.includes(args.billingCycle)) {
            throw new Error(`Invalid billing cycle: ${args.billingCycle}. Must be monthly or annual`);
        }

        const stripe = getStripeClient();
        const priceId = getPriceId(args.plan, args.billingCycle);

        // Check if customer already exists in Convex
        const existingCustomer = await ctx.runQuery(internal.stripe.getCustomerByEmail, {
            email: args.email,
        });

        const sessionParams: Stripe.Checkout.SessionCreateParams = {
            mode: 'subscription',
            payment_method_types: ['card'],
            line_items: [
                {
                    price: priceId,
                    quantity: 1,
                },
            ],
            success_url: args.successUrl,
            cancel_url: args.cancelUrl,
            metadata: {
                faxbella_plan: args.plan,
                faxbella_billing_cycle: args.billingCycle,
            },
        };

        // If customer already has a Stripe ID, reuse it
        if (existingCustomer?.stripeCustomerId && !existingCustomer.stripeCustomerId.startsWith('whop_')) {
            sessionParams.customer = existingCustomer.stripeCustomerId;
        } else {
            sessionParams.customer_email = args.email;
        }

        try {
            const session = await stripe.checkout.sessions.create(sessionParams);

            return {
                checkoutUrl: session.url,
                sessionId: session.id,
            };
        } catch (error) {
            const msg = error instanceof Error ? error.message : 'Failed to create checkout session';
            console.error('[STRIPE] Checkout error:', msg);
            throw new Error(msg);
        }
    },
});

/**
 * Create a Stripe Billing Portal session so the customer can manage
 * their subscription, update payment method, or cancel.
 */
export const createBillingPortalSession = action({
    args: {
        email: v.string(),
        returnUrl: v.string(),
    },
    handler: async (ctx, args) => {
        const stripe = getStripeClient();

        const customer = await ctx.runQuery(internal.stripe.getCustomerByEmail, {
            email: args.email,
        });

        if (!customer) {
            throw new Error('Customer not found');
        }

        if (!customer.stripeCustomerId || customer.stripeCustomerId.startsWith('whop_')) {
            throw new Error('No Stripe subscription found. This account may use an alternative payment processor.');
        }

        try {
            const session = await stripe.billingPortal.sessions.create({
                customer: customer.stripeCustomerId,
                return_url: args.returnUrl,
            });

            return {
                portalUrl: session.url,
            };
        } catch (error) {
            const msg = error instanceof Error ? error.message : 'Failed to create billing portal session';
            console.error('[STRIPE] Portal error:', msg);
            throw new Error(msg);
        }
    },
});

// ─── Webhook Handlers ────────────────────────────────────

/**
 * Process a completed checkout session. Creates or updates the customer
 * record with their Stripe IDs and plan information.
 */
export const handleCheckoutCompleted = internalMutation({
    args: {
        email: v.string(),
        plan: v.string(),
        stripeCustomerId: v.string(),
        stripeSubscriptionId: v.string(),
    },
    handler: async (ctx, args) => {
        const limits = PLAN_LIMITS[args.plan] || PLAN_LIMITS.standard;

        // Check if customer already exists
        const existing = await ctx.db
            .query('customers')
            .withIndex('by_email', (q) => q.eq('email', args.email))
            .first();

        if (existing) {
            await ctx.db.patch(existing._id, {
                plan: args.plan,
                planStatus: 'active',
                stripeCustomerId: args.stripeCustomerId,
                stripeSubscriptionId: args.stripeSubscriptionId,
                faxesLimit: limits.faxes,
                updatedAt: Date.now(),
            });
            return { customerId: existing._id, updated: true };
        }

        // Create new customer
        const webhookSecret = generateWebhookSecret();
        const customerId = await ctx.db.insert('customers', {
            email: args.email,
            stripeCustomerId: args.stripeCustomerId,
            stripeSubscriptionId: args.stripeSubscriptionId,
            plan: args.plan,
            planStatus: 'active',
            webhookSecret,
            faxesThisMonth: 0,
            faxesLimit: limits.faxes,
            createdAt: Date.now(),
        });

        return { customerId, updated: false };
    },
});

/**
 * Handle subscription updates from Stripe (plan changes, status changes).
 */
export const handleSubscriptionUpdated = internalMutation({
    args: {
        stripeSubscriptionId: v.string(),
        plan: v.string(),
        status: v.string(),
    },
    handler: async (ctx, args) => {
        // No index on stripeSubscriptionId, so query by stripeCustomerId index
        // is not possible. Scan all customers to find by subscription ID.
        const customers = await ctx.db.query('customers').collect();
        const customer = customers.find(
            (c) => c.stripeSubscriptionId === args.stripeSubscriptionId
        );

        if (!customer) {
            console.error(`[STRIPE] Customer not found for subscription: ${args.stripeSubscriptionId}`);
            return { success: false };
        }

        const limits = PLAN_LIMITS[args.plan] || PLAN_LIMITS[customer.plan] || PLAN_LIMITS.standard;

        // Map Stripe status to FaxBella status
        const statusMap: Record<string, string> = {
            active: 'active',
            past_due: 'past_due',
            canceled: 'canceled',
            unpaid: 'past_due',
            incomplete: 'past_due',
            incomplete_expired: 'canceled',
            trialing: 'active',
            paused: 'canceled',
        };

        const planStatus = statusMap[args.status] || 'active';

        await ctx.db.patch(customer._id, {
            plan: args.plan,
            planStatus,
            faxesLimit: limits.faxes,
            updatedAt: Date.now(),
        });

        return { success: true, email: customer.email };
    },
});

/**
 * Handle subscription deletion (cancellation) from Stripe.
 */
export const handleSubscriptionDeleted = internalMutation({
    args: {
        stripeSubscriptionId: v.string(),
    },
    handler: async (ctx, args) => {
        const customers = await ctx.db.query('customers').collect();
        const customer = customers.find(
            (c) => c.stripeSubscriptionId === args.stripeSubscriptionId
        );

        if (!customer) {
            console.error(`[STRIPE] Customer not found for subscription: ${args.stripeSubscriptionId}`);
            return { success: false };
        }

        await ctx.db.patch(customer._id, {
            planStatus: 'canceled',
            updatedAt: Date.now(),
        });

        return { success: true, email: customer.email };
    },
});

// ─── Email Notifications ─────────────────────────────────

/**
 * Send payment-related emails via EmailIt.
 * Supports confirmation and cancellation email types.
 */
export const sendPaymentEmail = internalAction({
    args: {
        to: v.string(),
        type: v.string(), // 'confirmation' | 'cancellation' | 'update'
        plan: v.optional(v.string()),
    },
    handler: async (_ctx, args) => {
        const emailitKey = process.env.EMAILIT_API_KEY;
        if (!emailitKey) {
            console.error('[STRIPE] EmailIt API key not configured');
            return { success: false };
        }

        const emailContent = buildPaymentEmailContent(args.type, args.plan);

        try {
            const response = await fetch('https://api.emailit.com/v1/emails', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${emailitKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    from: 'FaxBella <notifications@faxbella.com>',
                    to: args.to,
                    subject: emailContent.subject,
                    html: emailContent.html,
                }),
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('[STRIPE] EmailIt error:', response.status, errorText);
                return { success: false };
            }

            return { success: true };
        } catch (error) {
            console.error('[STRIPE] Email send failed:', error);
            return { success: false };
        }
    },
});

// ─── Email Templates ─────────────────────────────────────

function buildPaymentEmailContent(
    type: string,
    plan?: string
): { subject: string; html: string } {
    const planDisplay = plan ? plan.charAt(0).toUpperCase() + plan.slice(1) : 'your';

    switch (type) {
        case 'confirmation':
            return {
                subject: `Welcome to FaxBella ${planDisplay} Plan`,
                html: `
                    <div style="font-family: 'Inter', Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 40px 20px;">
                        <h1 style="color: #1a1a2e; font-size: 24px; font-weight: 500;">Welcome to FaxBella</h1>
                        <p style="color: #4a4a6a; font-size: 16px; line-height: 1.6;">
                            Your <strong>${planDisplay}</strong> plan is now active. You can start routing faxes with AI-powered intelligence right away.
                        </p>
                        <div style="background: #f8f7ff; border-radius: 8px; padding: 20px; margin: 24px 0;">
                            <p style="color: #4a4a6a; margin: 0; font-size: 14px;">
                                <strong>Next steps:</strong><br/>
                                1. Configure your HumbleFax credentials in Settings<br/>
                                2. Add recipients for fax routing<br/>
                                3. Set up your webhook URL in HumbleFax
                            </p>
                        </div>
                        <a href="https://faxbella.com/dashboard" style="display: inline-block; background: #6c5ce7; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-size: 14px;">
                            Go to Dashboard
                        </a>
                        <p style="color: #9a9aba; font-size: 12px; margin-top: 32px;">
                            FaxBella by Doclish Inc. | AI-Powered Fax Routing
                        </p>
                    </div>
                `,
            };

        case 'cancellation':
            return {
                subject: 'Your FaxBella subscription has been cancelled',
                html: `
                    <div style="font-family: 'Inter', Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 40px 20px;">
                        <h1 style="color: #1a1a2e; font-size: 24px; font-weight: 500;">Subscription Cancelled</h1>
                        <p style="color: #4a4a6a; font-size: 16px; line-height: 1.6;">
                            Your FaxBella subscription has been cancelled. Your fax routing will stop at the end of your current billing period.
                        </p>
                        <p style="color: #4a4a6a; font-size: 16px; line-height: 1.6;">
                            If this was a mistake or you'd like to resubscribe, you can do so from your dashboard at any time.
                        </p>
                        <a href="https://faxbella.com/dashboard" style="display: inline-block; background: #6c5ce7; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-size: 14px;">
                            Resubscribe
                        </a>
                        <p style="color: #9a9aba; font-size: 12px; margin-top: 32px;">
                            FaxBella by Doclish Inc. | AI-Powered Fax Routing
                        </p>
                    </div>
                `,
            };

        case 'update':
            return {
                subject: `FaxBella plan updated to ${planDisplay}`,
                html: `
                    <div style="font-family: 'Inter', Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 40px 20px;">
                        <h1 style="color: #1a1a2e; font-size: 24px; font-weight: 500;">Plan Updated</h1>
                        <p style="color: #4a4a6a; font-size: 16px; line-height: 1.6;">
                            Your FaxBella plan has been updated to <strong>${planDisplay}</strong>. Your new limits are now active.
                        </p>
                        <a href="https://faxbella.com/dashboard" style="display: inline-block; background: #6c5ce7; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-size: 14px;">
                            View Dashboard
                        </a>
                        <p style="color: #9a9aba; font-size: 12px; margin-top: 32px;">
                            FaxBella by Doclish Inc. | AI-Powered Fax Routing
                        </p>
                    </div>
                `,
            };

        default:
            return {
                subject: 'FaxBella Payment Update',
                html: `
                    <div style="font-family: 'Inter', Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 40px 20px;">
                        <h1 style="color: #1a1a2e; font-size: 24px; font-weight: 500;">Payment Update</h1>
                        <p style="color: #4a4a6a; font-size: 16px; line-height: 1.6;">
                            There has been an update to your FaxBella payment. Please check your dashboard for details.
                        </p>
                        <a href="https://faxbella.com/dashboard" style="display: inline-block; background: #6c5ce7; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-size: 14px;">
                            View Dashboard
                        </a>
                        <p style="color: #9a9aba; font-size: 12px; margin-top: 32px;">
                            FaxBella by Doclish Inc. | AI-Powered Fax Routing
                        </p>
                    </div>
                `,
            };
    }
}
