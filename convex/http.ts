/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck - Types are generated by Convex at deploy time
/**
 * HTTP Webhook Handler for FaxBella (faxbella.com)
 *
 * Receives webhooks from:
 *   - HumbleFax (inbound fax routing per customer)
 *   - Stripe (payment events: checkout, subscription changes)
 */

import { httpRouter } from 'convex/server';
import { httpAction } from './_generated/server';
import { internal } from './_generated/api';
import Stripe from 'stripe';

const http = httpRouter();

// Main webhook endpoint - customers configure this URL in HumbleFax
// URL format: /webhook/{customerWebhookSecret}
http.route({
    path: '/webhook/:secret',
    method: 'POST',
    handler: httpAction(async (ctx, request) => {
        try {
            // Extract customer secret from URL
            const url = new URL(request.url);
            const pathParts = url.pathname.split('/');
            const customerSecret = pathParts[pathParts.length - 1];

            if (!customerSecret) {
                return new Response(JSON.stringify({ error: 'Missing webhook secret' }), {
                    status: 401,
                    headers: { 'Content-Type': 'application/json' },
                });
            }

            // Find customer by webhook secret
            const customer = await ctx.runQuery(internal.faxRouting.getCustomerByWebhookSecret, {
                webhookSecret: customerSecret,
            });

            if (!customer) {
                return new Response(JSON.stringify({ error: 'Invalid webhook secret' }), {
                    status: 401,
                    headers: { 'Content-Type': 'application/json' },
                });
            }

            // Check plan limits
            if (customer.faxesThisMonth >= customer.faxesLimit) {
                console.log(`[WEBHOOK] Customer ${customer.email} exceeded fax limit`);
                return new Response(JSON.stringify({
                    error: 'Monthly fax limit exceeded',
                    limit: customer.faxesLimit,
                    used: customer.faxesThisMonth,
                }), {
                    status: 429,
                    headers: { 'Content-Type': 'application/json' },
                });
            }

            const payload = await request.json();

            // Only process incoming fax webhooks
            if (payload.type !== 'IncomingFax.SendComplete') {
                console.log(`[WEBHOOK] Ignoring event type: ${payload.type}`);
                return new Response(JSON.stringify({ success: true, message: 'Event ignored' }), {
                    status: 200,
                    headers: { 'Content-Type': 'application/json' },
                });
            }

            const incomingFax = payload.data?.IncomingFax;
            if (!incomingFax) {
                return new Response(JSON.stringify({ error: 'Invalid payload' }), {
                    status: 400,
                    headers: { 'Content-Type': 'application/json' },
                });
            }

            console.log(`[WEBHOOK] Incoming fax for ${customer.email} from ${incomingFax.fromNumber}`);

            // Store the fax and trigger AI routing
            const inboundFaxId = await ctx.runMutation(internal.faxRouting.storeInboundFax, {
                customerId: customer._id,
                providerFaxId: String(incomingFax.id),
                fromNumber: String(incomingFax.fromNumber || ''),
                toNumber: String(incomingFax.toNumber || ''),
                numPages: incomingFax.numPages || 1,
            });

            // Schedule AI routing (runs async)
            await ctx.scheduler.runAfter(0, internal.faxRouting.processInboundFaxWithAI, {
                inboundFaxId,
                customerId: customer._id,
                providerFaxId: String(incomingFax.id),
                fromNumber: String(incomingFax.fromNumber || ''),
            });

            return new Response(JSON.stringify({
                success: true,
                faxId: inboundFaxId,
                message: 'Fax queued for AI routing',
            }), {
                status: 200,
                headers: { 'Content-Type': 'application/json' },
            });

        } catch (error) {
            console.error('[WEBHOOK] Error:', error);
            return new Response(JSON.stringify({
                success: false,
                error: error instanceof Error ? error.message : 'Internal error',
            }), {
                status: 500,
                headers: { 'Content-Type': 'application/json' },
            });
        }
    }),
});

// ─── Stripe Webhook ──────────────────────────────────────

http.route({
    path: '/stripe',
    method: 'POST',
    handler: httpAction(async (ctx, request) => {
        const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
        if (!webhookSecret) {
            console.error('[STRIPE] Webhook secret not configured');
            return new Response(JSON.stringify({ error: 'Webhook not configured' }), {
                status: 500,
                headers: { 'Content-Type': 'application/json' },
            });
        }

        const signature = request.headers.get('stripe-signature');
        if (!signature) {
            return new Response(JSON.stringify({ error: 'Missing stripe-signature header' }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' },
            });
        }

        // Read raw body for signature verification
        const rawBody = await request.text();

        let event: Stripe.Event;
        try {
            const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
                apiVersion: '2024-12-18.acacia',
            });
            event = stripe.webhooks.constructEvent(rawBody, signature, webhookSecret);
        } catch (err) {
            const msg = err instanceof Error ? err.message : 'Signature verification failed';
            console.error('[STRIPE] Webhook signature verification failed:', msg);
            return new Response(JSON.stringify({ error: 'Invalid signature' }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' },
            });
        }

        console.log(`[STRIPE] Webhook event: ${event.type} (${event.id})`);

        try {
            switch (event.type) {
                case 'checkout.session.completed': {
                    const session = event.data.object as Stripe.Checkout.Session;
                    const email = session.customer_email || session.customer_details?.email;
                    const plan = session.metadata?.faxbella_plan || 'standard';
                    const stripeCustomerId = typeof session.customer === 'string'
                        ? session.customer
                        : session.customer?.id || '';
                    const stripeSubscriptionId = typeof session.subscription === 'string'
                        ? session.subscription
                        : session.subscription?.id || '';

                    if (!email) {
                        console.error('[STRIPE] No email in checkout session:', session.id);
                        break;
                    }

                    const quantity = parseInt(session.metadata?.faxbella_quantity || '1', 10);

                    await ctx.runMutation(internal.stripe.handleCheckoutCompleted, {
                        email,
                        plan,
                        stripeCustomerId,
                        stripeSubscriptionId,
                        quantity,
                    });

                    // Schedule confirmation email
                    await ctx.scheduler.runAfter(0, internal.stripe.sendPaymentEmail, {
                        to: email,
                        type: 'confirmation',
                        plan,
                    });

                    console.log(`[STRIPE] Checkout completed for ${email} (${plan})`);
                    break;
                }

                case 'customer.subscription.updated': {
                    const subscription = event.data.object as Stripe.Subscription;
                    const subscriptionId = subscription.id;
                    const status = subscription.status;

                    // Extract plan from subscription metadata or price lookup key
                    let plan = subscription.metadata?.faxbella_plan || '';
                    if (!plan && subscription.items?.data?.[0]) {
                        const price = subscription.items.data[0].price;
                        plan = price.lookup_key || price.metadata?.faxbella_plan || '';
                    }

                    // If we still cannot determine plan, default to current
                    if (!plan) {
                        plan = 'standard';
                    }

                    const result = await ctx.runMutation(internal.stripe.handleSubscriptionUpdated, {
                        stripeSubscriptionId: subscriptionId,
                        plan,
                        status,
                    });

                    // Send update email if customer was found
                    if (result.success && result.email) {
                        await ctx.scheduler.runAfter(0, internal.stripe.sendPaymentEmail, {
                            to: result.email,
                            type: 'update',
                            plan,
                        });
                    }

                    console.log(`[STRIPE] Subscription updated: ${subscriptionId} -> ${status}`);
                    break;
                }

                case 'customer.subscription.deleted': {
                    const subscription = event.data.object as Stripe.Subscription;
                    const subscriptionId = subscription.id;

                    const result = await ctx.runMutation(internal.stripe.handleSubscriptionDeleted, {
                        stripeSubscriptionId: subscriptionId,
                    });

                    // Send cancellation email if customer was found
                    if (result.success && result.email) {
                        await ctx.scheduler.runAfter(0, internal.stripe.sendPaymentEmail, {
                            to: result.email,
                            type: 'cancellation',
                        });
                    }

                    console.log(`[STRIPE] Subscription deleted: ${subscriptionId}`);
                    break;
                }

                default:
                    console.log(`[STRIPE] Unhandled event type: ${event.type}`);
            }
        } catch (error) {
            console.error(`[STRIPE] Error processing ${event.type}:`, error);
            // Return 200 to prevent Stripe from retrying (we logged the error)
            return new Response(JSON.stringify({ received: true, error: 'Processing error logged' }), {
                status: 200,
                headers: { 'Content-Type': 'application/json' },
            });
        }

        return new Response(JSON.stringify({ received: true }), {
            status: 200,
            headers: { 'Content-Type': 'application/json' },
        });
    }),
});

// ─── Whop Webhook ───────────────────────────────────────

http.route({
    path: '/whop',
    method: 'POST',
    handler: httpAction(async (ctx, request) => {
        const webhookSecret = process.env.WHOP_WEBHOOK_SECRET;
        if (!webhookSecret) {
            console.error('[WHOP] Webhook secret not configured');
            return new Response(JSON.stringify({ error: 'Webhook not configured' }), {
                status: 500,
                headers: { 'Content-Type': 'application/json' },
            });
        }

        // Verify webhook signature
        const signature = request.headers.get('whop-signature');
        if (!signature) {
            return new Response(JSON.stringify({ error: 'Missing whop-signature header' }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' },
            });
        }

        const rawBody = await request.text();

        // HMAC-SHA256 verification
        try {
            const encoder = new TextEncoder();
            const key = await crypto.subtle.importKey(
                'raw',
                encoder.encode(webhookSecret),
                { name: 'HMAC', hash: 'SHA-256' },
                false,
                ['sign']
            );
            const sig = await crypto.subtle.sign('HMAC', key, encoder.encode(rawBody));
            const computed = Array.from(new Uint8Array(sig))
                .map((b) => b.toString(16).padStart(2, '0'))
                .join('');

            if (computed !== signature) {
                console.error('[WHOP] Webhook signature mismatch');
                return new Response(JSON.stringify({ error: 'Invalid signature' }), {
                    status: 401,
                    headers: { 'Content-Type': 'application/json' },
                });
            }
        } catch (err) {
            console.error('[WHOP] Signature verification error:', err);
            return new Response(JSON.stringify({ error: 'Signature verification failed' }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' },
            });
        }

        let payload;
        try {
            payload = JSON.parse(rawBody);
        } catch {
            return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' },
            });
        }

        const eventType = payload.event || payload.action;
        console.log(`[WHOP] Webhook event: ${eventType}`);

        try {
            switch (eventType) {
                case 'membership_activated':
                case 'payment_succeeded': {
                    const membership = payload.data?.membership || payload.data;
                    const email = membership?.metadata?.email || membership?.user?.email || '';
                    const plan = membership?.metadata?.faxbella_plan || 'standard';
                    const membershipId = membership?.id || '';
                    const customerId = membership?.user?.id || '';

                    if (email) {
                        await ctx.runMutation(internal.whop.handleWhopSubscriptionCreated, {
                            email,
                            plan,
                            whopMembershipId: membershipId,
                            whopCustomerId: customerId,
                        });

                        await ctx.scheduler.runAfter(0, internal.whop.sendWhopEmail, {
                            to: email,
                            subject: 'Welcome to FaxBella',
                            html: `<p>Your FaxBella ${plan} plan is now active. <a href="https://faxbella.com/dashboard">Go to your dashboard</a>.</p>`,
                        });

                        console.log(`[WHOP] Subscription created for ${email} (${plan})`);
                    }
                    break;
                }

                case 'membership_deactivated':
                case 'payment_failed': {
                    const membership = payload.data?.membership || payload.data;
                    const membershipId = membership?.id || '';

                    if (membershipId) {
                        const result = await ctx.runMutation(internal.whop.handleWhopSubscriptionCancelled, {
                            whopMembershipId: membershipId,
                        });

                        if (result.success && result.email) {
                            await ctx.scheduler.runAfter(0, internal.whop.sendWhopEmail, {
                                to: result.email,
                                subject: 'FaxBella Subscription Update',
                                html: '<p>Your FaxBella subscription has been deactivated. <a href="https://faxbella.com/pricing">Reactivate your plan</a>.</p>',
                            });
                        }

                        console.log(`[WHOP] Subscription cancelled: ${membershipId}`);
                    }
                    break;
                }

                default:
                    console.log(`[WHOP] Unhandled event type: ${eventType}`);
            }
        } catch (error) {
            console.error(`[WHOP] Error processing ${eventType}:`, error);
            return new Response(JSON.stringify({ received: true, error: 'Processing error logged' }), {
                status: 200,
                headers: { 'Content-Type': 'application/json' },
            });
        }

        return new Response(JSON.stringify({ received: true }), {
            status: 200,
            headers: { 'Content-Type': 'application/json' },
        });
    }),
});

// ─── Health Check ────────────────────────────────────────

http.route({
    path: '/health',
    method: 'GET',
    handler: httpAction(async () => {
        return new Response(JSON.stringify({
            status: 'ok',
            service: 'FaxBella',
            timestamp: new Date().toISOString(),
        }), {
            status: 200,
            headers: { 'Content-Type': 'application/json' },
        });
    }),
});

export default http;
