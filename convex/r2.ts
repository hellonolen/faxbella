/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck - Types are generated by Convex at deploy time
/**
 * R2 Storage Layer for FaxBella
 *
 * Cloudflare R2 via S3-compatible API (AWS SDK).
 * Provides presigned URLs for client upload/download,
 * server-side upload from buffer, and file management.
 *
 * R2 key structure:
 *   accounts/{customerId}/inbound/{timestamp}_{fileName}
 *   accounts/{customerId}/outbound/{timestamp}_{fileName}
 */

import { action, internalAction } from './_generated/server';
import { internal } from './_generated/api';
import { v } from 'convex/values';
import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand, ListObjectsV2Command } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

/* ─── Helpers ──────────────────────────────────────────── */

function getR2Client(): S3Client {
    const accountId = process.env.R2_ACCOUNT_ID;
    const accessKeyId = process.env.R2_ACCESS_KEY_ID;
    const secretAccessKey = process.env.R2_SECRET_ACCESS_KEY;

    if (!accountId || !accessKeyId || !secretAccessKey) {
        throw new Error('R2 credentials not configured. Set R2_ACCOUNT_ID, R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY in Convex env.');
    }

    return new S3Client({
        region: 'auto',
        endpoint: `https://${accountId}.r2.cloudflarestorage.com`,
        credentials: {
            accessKeyId,
            secretAccessKey,
        },
    });
}

function getBucketName(): string {
    const bucket = process.env.R2_BUCKET_NAME;
    if (!bucket) {
        throw new Error('R2_BUCKET_NAME not configured in Convex env.');
    }
    return bucket;
}

function buildObjectKey(
    customerId: string,
    direction: 'inbound' | 'outbound',
    fileName: string,
): string {
    const timestamp = Date.now();
    const sanitizedName = fileName.replace(/[^a-zA-Z0-9._-]/g, '_');
    return `accounts/${customerId}/${direction}/${timestamp}_${sanitizedName}`;
}

/**
 * Validate that an R2 object key follows the expected namespace pattern.
 * Prevents path traversal and cross-account access.
 */
function validateObjectKey(objectKey: string): void {
    if (!objectKey || typeof objectKey !== 'string') {
        throw new Error('Invalid object key');
    }
    // Must start with accounts/ prefix
    if (!objectKey.startsWith('accounts/')) {
        throw new Error('Invalid object key format');
    }
    // Must not contain path traversal sequences
    if (objectKey.includes('..') || objectKey.includes('//')) {
        throw new Error('Invalid object key: path traversal detected');
    }
}

/* ─── Public Actions ───────────────────────────────────── */

/**
 * Generate a presigned PUT URL for client-side upload.
 * Client uploads directly to R2 — no file data passes through Convex.
 */
export const getPresignedUploadUrl = action({
    args: {
        email: v.string(),
        fileName: v.string(),
        fileSize: v.number(),
        mimeType: v.string(),
        direction: v.union(v.literal('inbound'), v.literal('outbound')),
    },
    handler: async (ctx, args) => {
        // Verify customer ownership
        const customer = await ctx.runQuery(internal.customers.getCustomerByEmail, {
            email: args.email,
        });
        if (!customer) {
            throw new Error('Customer not found');
        }

        // Plan-based size limits: 20MB Business, 50MB Enterprise
        const maxSize = customer.plan === 'enterprise' ? 50 * 1024 * 1024 : 20 * 1024 * 1024;
        if (args.fileSize > maxSize) {
            throw new Error(`File size exceeds ${maxSize / (1024 * 1024)}MB limit for your plan`);
        }

        const objectKey = buildObjectKey(String(customer._id), args.direction, args.fileName);
        const client = getR2Client();
        const bucket = getBucketName();

        const command = new PutObjectCommand({
            Bucket: bucket,
            Key: objectKey,
            ContentType: args.mimeType,
            ContentLength: args.fileSize,
        });

        const uploadUrl = await getSignedUrl(client, command, { expiresIn: 900 }); // 15 min

        return {
            uploadUrl,
            objectKey,
        };
    },
});

/**
 * Generate a presigned GET URL for viewing/downloading a file.
 * Validates customer ownership before generating URL.
 */
export const getPresignedDownloadUrl = action({
    args: {
        email: v.string(),
        objectKey: v.string(),
    },
    handler: async (ctx, args) => {
        // Verify customer ownership — key must start with their account prefix
        const customer = await ctx.runQuery(internal.customers.getCustomerByEmail, {
            email: args.email,
        });
        if (!customer) {
            throw new Error('Customer not found');
        }

        const expectedPrefix = `accounts/${String(customer._id)}/`;
        if (!args.objectKey.startsWith(expectedPrefix)) {
            throw new Error('Access denied — file does not belong to your account');
        }

        const client = getR2Client();
        const bucket = getBucketName();

        const command = new GetObjectCommand({
            Bucket: bucket,
            Key: args.objectKey,
        });

        const downloadUrl = await getSignedUrl(client, command, { expiresIn: 900 }); // 15 min

        return { downloadUrl };
    },
});

/* ─── Internal Actions (server-side only) ──────────────── */

/**
 * Generate a presigned GET URL without customer ownership check.
 * Only callable from other Convex functions that have already verified ownership.
 */
export const getPresignedDownloadUrlInternal = internalAction({
    args: {
        objectKey: v.string(),
    },
    handler: async (_ctx, args) => {
        const client = getR2Client();
        const bucket = getBucketName();

        const command = new GetObjectCommand({
            Bucket: bucket,
            Key: args.objectKey,
        });

        const downloadUrl = await getSignedUrl(client, command, { expiresIn: 900 }); // 15 min
        return { downloadUrl };
    },
});

/**
 * Upload a file buffer to R2 from server-side (e.g. during fax processing).
 * Returns the R2 object key.
 */
export const uploadFromBuffer = internalAction({
    args: {
        customerId: v.string(),
        buffer: v.string(), // Base64-encoded file content
        fileName: v.string(),
        mimeType: v.string(),
        direction: v.union(v.literal('inbound'), v.literal('outbound')),
    },
    handler: async (_ctx, args) => {
        const objectKey = buildObjectKey(args.customerId, args.direction, args.fileName);
        const client = getR2Client();
        const bucket = getBucketName();

        const body = Buffer.from(args.buffer, 'base64');

        await client.send(new PutObjectCommand({
            Bucket: bucket,
            Key: objectKey,
            Body: body,
            ContentType: args.mimeType,
        }));

        return {
            objectKey,
            fileSize: body.length,
        };
    },
});

/**
 * Download a file from R2 as a Buffer (for server-side processing like cover page merge).
 */
export const downloadToBuffer = internalAction({
    args: {
        objectKey: v.string(),
    },
    handler: async (_ctx, args) => {
        validateObjectKey(args.objectKey);
        const client = getR2Client();
        const bucket = getBucketName();

        const response = await client.send(new GetObjectCommand({
            Bucket: bucket,
            Key: args.objectKey,
        }));

        if (!response.Body) {
            throw new Error('Empty response from R2');
        }

        const chunks: Uint8Array[] = [];
        for await (const chunk of response.Body as AsyncIterable<Uint8Array>) {
            chunks.push(chunk);
        }
        const buffer = Buffer.concat(chunks);
        return buffer.toString('base64');
    },
});

/**
 * Delete a file from R2.
 */
export const deleteObject = internalAction({
    args: {
        objectKey: v.string(),
    },
    handler: async (_ctx, args) => {
        validateObjectKey(args.objectKey);
        const client = getR2Client();
        const bucket = getBucketName();

        await client.send(new DeleteObjectCommand({
            Bucket: bucket,
            Key: args.objectKey,
        }));

        return { success: true };
    },
});

/**
 * List all files for a customer account.
 */
export const listAccountFiles = internalAction({
    args: {
        customerId: v.string(),
        direction: v.optional(v.union(v.literal('inbound'), v.literal('outbound'))),
    },
    handler: async (_ctx, args) => {
        const client = getR2Client();
        const bucket = getBucketName();

        const prefix = args.direction
            ? `accounts/${args.customerId}/${args.direction}/`
            : `accounts/${args.customerId}/`;

        const response = await client.send(new ListObjectsV2Command({
            Bucket: bucket,
            Prefix: prefix,
            MaxKeys: 1000,
        }));

        return (response.Contents || []).map((obj) => ({
            key: obj.Key || '',
            size: obj.Size || 0,
            lastModified: obj.LastModified?.toISOString() || '',
        }));
    },
});
